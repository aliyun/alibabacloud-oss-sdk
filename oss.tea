
import Util;
import OSSUtil;
import XML;
import FileForm;
import Credential;

type @endpoint = string
type @regionId = string
type @hostModel = string
type @protocol = string
type @readTimeout = number
type @connectTimeout = number
type @signatureVersion = string
type @addtionalHeaders = [ string ]
type @localAddr = string
type @httpProxy = string
type @httpsProxy = string
type @noProxy = string
type @userAgent = string
type @socks5Proxy = string
type @isEnableCrc = boolean
type @isEnableMD5 = boolean
type @socks5NetWork = string
type @maxIdleConns = number
type @credential = Credential

model Config {
  type?: string,
  securityToken?: string,
  accessKeyId: string,
  accessKeySecret: string,
  endpoint?: string,
  protocol?: string,
  regionId?: string(pattern='[a-zA-Z0-9-_]+'),
  userAgent?: string,
  hostModel?: string,
  signatureVersion?: string,
  isEnableMD5?: boolean,
  isEnableCrc?: boolean,
  readTimeout?: number,
  connectTimeout?: number,
  localAddr?: string,
  httpProxy?: string,
  httpsProxy?: string,
  noProxy?: string,
  socks5Proxy?: string,
  socks5NetWork?: string,
  maxIdleConns?: number,
  addtionalHeaders?: [ string ],
}


init(config: Config){
  if (Util.isUnset(config)) {
    throw {
      name = "ParameterMissing",
      message = "'config' can not be unset"
    };
  }

  if (Util.empty(config.type)) {
    config.type = 'access_key';
  }
  var credentialConfig = new Credential.Config{
    accessKeyId =  config.accessKeyId,
    type = config.type,
    accessKeySecret =  config.accessKeySecret,
    securityToken = config.securityToken,
  };
  @credential = new Credential(credentialConfig);
  if (Util.isUnset(config.isEnableMD5)) {
    config.isEnableMD5 = false;
  }
  if (Util.isUnset(config.isEnableCrc)) {
    config.isEnableCrc = false;
  }
  @endpoint = config.endpoint;
  @protocol = config.protocol;
  @regionId = config.regionId;
  @userAgent = config.userAgent;
  @readTimeout = config.readTimeout;
  @connectTimeout = config.connectTimeout;
  @localAddr = config.localAddr;
  @httpProxy = config.httpProxy;
  @httpsProxy = config.httpsProxy;
  @noProxy = config.noProxy;
  @socks5Proxy = config.socks5Proxy;
  @socks5NetWork = config.socks5NetWork;
  @maxIdleConns = config.maxIdleConns;
  @signatureVersion = config.signatureVersion;
  @addtionalHeaders = config.addtionalHeaders;
  @hostModel = config.hostModel;
  @isEnableMD5 = config.isEnableMD5;
  @isEnableCrc = config.isEnableCrc;
}

model PutBucketLifecycleRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    lifecycleConfiguration: {
      rule?: [
        {
          expiration?: {
            days?: integer(description='Days', name='Days'),
            createdBeforeDate?: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
          }(description='Expiration', name='Expiration'),
          transition?: {
            days?: integer(description='Days', name='Days'),
            storageClass?: string(description='StorageClass', name='StorageClass'),
          }(description='Transition', name='Transition'),
          abortMultipartUpload?: {
            days?: integer(description='Days', name='Days'),
            createdBeforeDate?: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
          }(description='AbortMultipartUpload', name='AbortMultipartUpload'),
          tag?: {
            key?: string(description='Key', name='Key'),
            value?: string(description='Value', name='Value'),
          }(description='Tag', name='Tag'),
          iD?: string(description='ID', name='ID'),
          prefix?: string(description='Prefix', name='Prefix'),
          status?: string(description='Status', name='Status'),
        }
      ](description='Rule', name='Rule'),
    }(description='LifecycleConfiguration', name='LifecycleConfiguration'),
  }(description='Body', name='Body'),
}

model PutBucketLifecycleResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketLifecycle(request: PutBucketLifecycleRequest, runtime: OSSUtil.RuntimeOptions): PutBucketLifecycleResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?lifecycle`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteMultipleObjectsRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    delete: {
      object?: [
        {
          key?: string(description='Key', name='Key'),
        }
      ](description='Object', name='Object'),
      quiet?: string(description='Quiet', name='Quiet'),
    }(description='Delete', name='Delete'),
  }(description='Body', name='Body'),
  header: {
    encodingType?: string(description='Encoding-type', name='Encoding-type'),
    contentLength: string(description='Content-Length', name='Content-Length'),
    contentMD5: string(description='Content-MD5', name='Content-MD5'),
  }(description='Header', name='Header'),
}

model DeleteMultipleObjectsResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  deleteResult: {
    quiet?: string(description='Quiet', name='Quiet'),
    encodingType?: string(description='EncodingType', name='EncodingType'),
    deleted?: [
      {
        key?: string(description='Key', name='Key'),
      }
    ](description='Deleted', name='Deleted'),
  }(description='DeleteResult', name='DeleteResult'),
}

api deleteMultipleObjects(request: DeleteMultipleObjectsRequest, runtime: OSSUtil.RuntimeOptions): DeleteMultipleObjectsResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/?delete`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  if (!Util.isUnset(request.header) && !Util.empty(request.header.contentMD5)) {
    __request.headers.content-md5 = request.header.contentMD5;
  } else {
    __request.headers.content-md5 = OSSUtil.getContentMD5(reqBody, @isEnableMD5);
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, DeleteMultipleObjectsResponse);
  return {
    DeleteResult = respMap.DeleteResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketRefererRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    refererConfiguration: {
      refererList?: {
        referer?: [ string ](description='Referer', name='Referer'),
      }(description='RefererList', name='RefererList'),
      allowEmptyReferer?: boolean(description='AllowEmptyReferer', name='AllowEmptyReferer'),
    }(description='RefererConfiguration', name='RefererConfiguration'),
  }(description='Body', name='Body'),
}

model PutBucketRefererResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketReferer(request: PutBucketRefererRequest, runtime: OSSUtil.RuntimeOptions): PutBucketRefererResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?referer`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketWebsiteRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    websiteConfiguration: {
      indexDocument?: {
        suffix?: string(description='Suffix', name='Suffix'),
      }(description='IndexDocument', name='IndexDocument'),
      errorDocument?: {
        key?: string(description='Key', name='Key'),
      }(description='ErrorDocument', name='ErrorDocument'),
      routingRules?: {
        routingRule?: [
          {
            condition?: {
              includeHeader?: {
                key?: string(description='Key', name='Key'),
                equals?: string(description='Equals', name='Equals'),
              }(description='IncludeHeader', name='IncludeHeader'),
              keyPrefixEquals?: string(description='KeyPrefixEquals', name='KeyPrefixEquals'),
              httpErrorCodeReturnedEquals?: string(description='HttpErrorCodeReturnedEquals', name='HttpErrorCodeReturnedEquals'),
            }(description='Condition', name='Condition'),
            redirect?: {
              mirrorHeaders?: {
                set?: {
                  key?: string(description='Key', name='Key'),
                  value?: string(description='Value', name='Value'),
                }(description='Set', name='Set'),
                passAll?: boolean(description='PassAll', name='PassAll'),
                pass?: string(description='Pass', name='Pass'),
                remove?: string(description='Remove', name='Remove'),
              }(description='MirrorHeaders', name='MirrorHeaders'),
              redirectType?: string(description='RedirectType', name='RedirectType'),
              passQueryString?: boolean(description='PassQueryString', name='PassQueryString'),
              mirrorURL?: string(description='MirrorURL', name='MirrorURL'),
              mirrorPassQueryString?: boolean(description='MirrorPassQueryString', name='MirrorPassQueryString'),
              mirrorFollowRedirect?: boolean(description='MirrorFollowRedirect', name='MirrorFollowRedirect'),
              mirrorCheckMd5?: boolean(description='MirrorCheckMd5', name='MirrorCheckMd5'),
              protocol?: string(description='Protocol', name='Protocol'),
              hostName?: string(description='HostName', name='HostName'),
              httpRedirectCode?: string(description='HttpRedirectCode', name='HttpRedirectCode'),
              replaceKeyPrefixWith?: string(description='ReplaceKeyPrefixWith', name='ReplaceKeyPrefixWith'),
              replaceKeyWith?: string(description='ReplaceKeyWith', name='ReplaceKeyWith'),
            }(description='Redirect', name='Redirect'),
            ruleNumber?: integer(description='RuleNumber', name='RuleNumber'),
          }
        ](description='RoutingRule', name='RoutingRule'),
      }(description='RoutingRules', name='RoutingRules'),
    }(description='WebsiteConfiguration', name='WebsiteConfiguration'),
  }(description='Body', name='Body'),
}

model PutBucketWebsiteResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketWebsite(request: PutBucketWebsiteRequest, runtime: OSSUtil.RuntimeOptions): PutBucketWebsiteResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?website`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model CompleteMultipartUploadRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  filter: {
    uploadId: string(description='uploadId', name='uploadId', signed='true'),
    encodingType?: string(description='Encoding-type', name='Encoding-type'),
  }(description='Filter', name='Filter'),
  body?: {
    completeMultipartUpload: {
      part?: [
        {
          partNumber?: string(description='PartNumber', name='PartNumber'),
          eTag?: string(description='ETag', name='ETag'),
        }
      ](description='Part', name='Part'),
    }(description='CompleteMultipartUpload', name='CompleteMultipartUpload'),
  }(description='Body', name='Body'),
}

model CompleteMultipartUploadResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  completeMultipartUploadResult: {
    bucket?: string(description='Bucket', name='Bucket'),
    eTag?: string(description='ETag', name='ETag'),
    location?: string(description='Location', name='Location'),
    key?: string(description='Key', name='Key'),
    encodingType?: string(description='EncodingType', name='EncodingType'),
  }(description='CompleteMultipartUploadResult', name='CompleteMultipartUploadResult'),
}

api completeMultipartUpload(request: CompleteMultipartUploadRequest, runtime: OSSUtil.RuntimeOptions): CompleteMultipartUploadResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, CompleteMultipartUploadResponse);
  return {
    CompleteMultipartUploadResult = respMap.CompleteMultipartUploadResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketLoggingRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    bucketLoggingStatus: {
      loggingEnabled?: {
        targetBucket?: string(description='TargetBucket', name='TargetBucket'),
        targetPrefix?: string(description='TargetPrefix', name='TargetPrefix'),
      }(description='LoggingEnabled', name='LoggingEnabled'),
    }(description='BucketLoggingStatus', name='BucketLoggingStatus'),
  }(description='Body', name='Body'),
}

model PutBucketLoggingResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketLogging(request: PutBucketLoggingRequest, runtime: OSSUtil.RuntimeOptions): PutBucketLoggingResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?logging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketRequestPaymentRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    requestPaymentConfiguration: {
      payer?: string(description='Payer', name='Payer'),
    }(description='RequestPaymentConfiguration', name='RequestPaymentConfiguration'),
  }(description='Body', name='Body'),
}

model PutBucketRequestPaymentResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketRequestPayment(request: PutBucketRequestPaymentRequest, runtime: OSSUtil.RuntimeOptions): PutBucketRequestPaymentResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?requestPayment`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketEncryptionRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    serverSideEncryptionRule: {
      applyServerSideEncryptionByDefault?: {
        sSEAlgorithm?: string(description='SSEAlgorithm', name='SSEAlgorithm'),
        kMSMasterKeyID?: string(description='KMSMasterKeyID', name='KMSMasterKeyID'),
      }(description='ApplyServerSideEncryptionByDefault', name='ApplyServerSideEncryptionByDefault'),
    }(description='ServerSideEncryptionRule', name='ServerSideEncryptionRule'),
  }(description='Body', name='Body'),
}

model PutBucketEncryptionResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketEncryption(request: PutBucketEncryptionRequest, runtime: OSSUtil.RuntimeOptions): PutBucketEncryptionResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?encryption`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutLiveChannelRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
  body?: {
    liveChannelConfiguration: {
      target?: {
        type?: string(description='Type', name='Type'),
        fragDuration?: string(description='FragDuration', name='FragDuration'),
        fragCount?: string(description='FragCount', name='FragCount'),
        playlistName?: string(description='PlaylistName', name='PlaylistName'),
      }(description='Target', name='Target'),
      snapshot?: {
        roleName?: string(description='RoleName', name='RoleName'),
        destBucket?: string(description='DestBucket', name='DestBucket'),
        notifyTopic?: string(description='NotifyTopic', name='NotifyTopic'),
        interval?: string(description='Interval', name='Interval'),
      }(description='Snapshot', name='Snapshot'),
      description?: string(description='Description', name='Description'),
      status?: string(description='Status', name='Status'),
    }(description='LiveChannelConfiguration', name='LiveChannelConfiguration'),
  }(description='Body', name='Body'),
}

model PutLiveChannelResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  createLiveChannelResult: {
    publishUrls: {
      url?: string(description='Url', name='Url'),
    }(description='PublishUrls', name='PublishUrls'),
    playUrls: {
      url?: string(description='Url', name='Url'),
    }(description='PlayUrls', name='PlayUrls'),
  }(description='CreateLiveChannelResult', name='CreateLiveChannelResult'),
}

api putLiveChannel(request: PutLiveChannelRequest, runtime: OSSUtil.RuntimeOptions): PutLiveChannelResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.channelName}?live`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, PutLiveChannelResponse);
  return {
    CreateLiveChannelResult = respMap.CreateLiveChannelResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketTagsRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    tagging: {
      tagSet?: {
        tag?: [
          {
            key?: string(description='Key', name='Key'),
            value?: string(description='Value', name='Value'),
          }
        ](description='Tag', name='Tag'),
      }(description='TagSet', name='TagSet'),
    }(description='Tagging', name='Tagging'),
  }(description='Body', name='Body'),
}

model PutBucketTagsResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketTags(request: PutBucketTagsRequest, runtime: OSSUtil.RuntimeOptions): PutBucketTagsResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?tagging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutObjectTaggingRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  body?: {
    tagging: {
      tagSet?: {
        tag?: [
          {
            key?: string(description='Key', name='Key'),
            value?: string(description='Value', name='Value'),
          }
        ](description='Tag', name='Tag'),
      }(description='TagSet', name='TagSet'),
    }(description='Tagging', name='Tagging'),
  }(description='Body', name='Body'),
}

model PutObjectTaggingResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putObjectTagging(request: PutObjectTaggingRequest, runtime: OSSUtil.RuntimeOptions): PutObjectTaggingResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.objectName}?tagging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model SelectObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  filter: {
    porcess: string(description='x-oss-process', name='x-oss-process'),
  }(description='Filter', name='Filter'),
  body?: {
    selectRequest: {
      inputSerialization?: {
        cSV?: {
          fileHeaderInfo?: string(description='FileHeaderInfo', name='FileHeaderInfo'),
          recordDelimiter?: string(description='RecordDelimiter', name='RecordDelimiter'),
          fieldDelimiter?: string(description='FieldDelimiter', name='FieldDelimiter'),
          quoteCharacter?: string(description='QuoteCharacter', name='QuoteCharacter'),
          commentCharacter?: string(description='CommentCharacter', name='CommentCharacter'),
          range?: string(description='Range', name='Range'),
        }(description='CSV', name='CSV'),
        compressionType?: string(description='CompressionType', name='CompressionType'),
      }(description='InputSerialization', name='InputSerialization'),
      outputSerialization?: {
        cSV?: {
          recordDelimiter?: string(description='RecordDelimiter', name='RecordDelimiter'),
          fieldDelimiter?: string(description='FieldDelimiter', name='FieldDelimiter'),
        }(description='CSV', name='CSV'),
        keepAllColumns?: string(description='KeepAllColumns', name='KeepAllColumns'),
        outputRawData?: string(description='OutputRawData', name='OutputRawData'),
        enablePayloadCrc?: string(description='EnablePayloadCrc', name='EnablePayloadCrc'),
        outputHeader?: string(description='OutputHeader', name='OutputHeader'),
      }(description='OutputSerialization', name='OutputSerialization'),
      options?: {
        skipPartialDataRecord?: string(description='SkipPartialDataRecord', name='SkipPartialDataRecord'),
        maxSkippedRecordsAllowed?: string(description='MaxSkippedRecordsAllowed', name='MaxSkippedRecordsAllowed'),
      }(description='Options', name='Options'),
      expression?: string(description='Expression', name='Expression'),
    }(description='SelectRequest', name='SelectRequest'),
  }(description='Body', name='Body'),
}

model SelectObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api selectObject(request: SelectObjectRequest, runtime: OSSUtil.RuntimeOptions): SelectObjectResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketCORSRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    cORSConfiguration: {
      cORSRule?: [
        {
          allowedOrigin?: [ string ](description='AllowedOrigin', name='AllowedOrigin'),
          allowedMethod?: [ string ](description='AllowedMethod', name='AllowedMethod'),
          allowedHeader?: [ string ](description='AllowedHeader', name='AllowedHeader'),
          exposeHeader?: [ string ](description='ExposeHeader', name='ExposeHeader'),
          maxAgeSeconds?: string(description='MaxAgeSeconds', name='MaxAgeSeconds'),
        }
      ](description='CORSRule', name='CORSRule'),
    }(description='CORSConfiguration', name='CORSConfiguration'),
  }(description='Body', name='Body'),
}

model PutBucketCORSResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketCORS(request: PutBucketCORSRequest, runtime: OSSUtil.RuntimeOptions): PutBucketCORSResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?cors`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  body?: {
    createBucketConfiguration: {
      storageClass?: string(description='StorageClass', name='StorageClass'),
      dataRedundancyType?: string(description='DataRedundancyType', name='DataRedundancyType'),
    }(description='CreateBucketConfiguration', name='CreateBucketConfiguration'),
  }(description='Body', name='Body'),
  header?: {
    acl?: string(description='x-oss-acl', name='x-oss-acl'),
  }(description='Header', name='Header'),
}

model PutBucketResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucket(request: PutBucketRequest, runtime: OSSUtil.RuntimeOptions): PutBucketResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  var reqBody = XML.toXML(request.body);
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = reqBody;
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model ListMultipartUploadsRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  filter?: {
    delimiter?: string(description='delimiter', name='delimiter'),
    maxUploads?: string(description='max-uploads', name='max-uploads'),
    keyMarker?: string(description='key-marker', name='key-marker'),
    prefix?: string(description='prefix', name='prefix'),
    uploadIdMarker?: string(description='upload-id-marker', name='upload-id-marker'),
    encodingType?: string(description='encoding-type', name='encoding-type'),
  }(description='Filter', name='Filter'),
}

model ListMultipartUploadsResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  listMultipartUploadsResult: {
    bucket?: string(description='Bucket', name='Bucket'),
    encodingType?: string(description='EncodingType', name='EncodingType'),
    keyMarker?: string(description='KeyMarker', name='KeyMarker'),
    uploadIdMarker?: string(description='UploadIdMarker', name='UploadIdMarker'),
    nextKeyMarker?: string(description='NextKeyMarker', name='NextKeyMarker'),
    nextUploadIdMarker?: string(description='NextUploadIdMarker', name='NextUploadIdMarker'),
    delimiter?: string(description='Delimiter', name='Delimiter'),
    maxUploads?: string(description='MaxUploads', name='MaxUploads'),
    isTruncated?: string(description='IsTruncated', name='IsTruncated'),
    upload?: [
      {
        key?: string(description='Key', name='Key'),
        uploadId?: string(description='UploadId', name='UploadId'),
        initiated?: string(description='Initiated', name='Initiated'),
      }
    ](description='Upload', name='Upload'),
  }(description='ListMultipartUploadsResult', name='ListMultipartUploadsResult'),
}

api listMultipartUploads(request: ListMultipartUploadsRequest, runtime: OSSUtil.RuntimeOptions): ListMultipartUploadsResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?uploads`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, ListMultipartUploadsResponse);
  return {
    ListMultipartUploadsResult = respMap.ListMultipartUploadsResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketRequestPaymentRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketRequestPaymentResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  requestPaymentConfiguration: {
    payer?: string(description='Payer', name='Payer'),
  }(description='RequestPaymentConfiguration', name='RequestPaymentConfiguration'),
}

api getBucketRequestPayment(request: GetBucketRequestPaymentRequest, runtime: OSSUtil.RuntimeOptions): GetBucketRequestPaymentResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?requestPayment`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketRequestPaymentResponse);
  return {
    RequestPaymentConfiguration = respMap.RequestPaymentConfiguration,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketEncryptionRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketEncryptionResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  serverSideEncryptionRule: {
    applyServerSideEncryptionByDefault: {
      sSEAlgorithm?: string(description='SSEAlgorithm', name='SSEAlgorithm'),
      kMSMasterKeyID?: string(description='KMSMasterKeyID', name='KMSMasterKeyID'),
    }(description='ApplyServerSideEncryptionByDefault', name='ApplyServerSideEncryptionByDefault'),
  }(description='ServerSideEncryptionRule', name='ServerSideEncryptionRule'),
}

api getBucketEncryption(request: GetBucketEncryptionRequest, runtime: OSSUtil.RuntimeOptions): GetBucketEncryptionResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?encryption`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketEncryptionResponse);
  return {
    ServerSideEncryptionRule = respMap.ServerSideEncryptionRule,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketTagsRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketTagsResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  tagging: {
    tagSet: {
      tag?: [
        {
          key?: string(description='Key', name='Key'),
          value?: string(description='Value', name='Value'),
        }
      ](description='Tag', name='Tag'),
    }(description='TagSet', name='TagSet'),
  }(description='Tagging', name='Tagging'),
}

api getBucketTags(request: GetBucketTagsRequest, runtime: OSSUtil.RuntimeOptions): GetBucketTagsResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?tagging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketTagsResponse);
  return {
    Tagging = respMap.Tagging,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetServiceRequest = {
  filter?: {
    prefix?: string(description='prefix', name='prefix'),
    marker?: string(description='marker', name='marker'),
    maxKeys?: string(description='max-keys', name='max-keys'),
  }(description='Filter', name='Filter'),
}

model GetServiceResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  listAllMyBucketsResult: {
    prefix?: string(description='Prefix', name='Prefix'),
    marker?: string(description='Marker', name='Marker'),
    maxKeys?: string(description='MaxKeys', name='MaxKeys'),
    isTruncated?: string(description='IsTruncated', name='IsTruncated'),
    nextMarker?: string(description='NextMarker', name='NextMarker'),
    owner: {
      iD?: string(description='ID', name='ID'),
      displayName?: string(description='DisplayName', name='DisplayName'),
    }(description='Owner', name='Owner'),
    buckets: {
      bucket?: [
        {
          name?: string(description='Name', name='Name'),
          createDate?: string(description='CreateDate', name='CreateDate'),
          location?: string(description='Location', name='Location'),
          extranetEndpoint?: string(description='ExtranetEndpoint', name='ExtranetEndpoint'),
          intranetEndpoint?: string(description='IntranetEndpoint', name='IntranetEndpoint'),
          storageClass?: string(description='StorageClass', name='StorageClass'),
        }
      ](description='Bucket', name='Bucket'),
    }(description='Buckets', name='Buckets'),
  }(description='ListAllMyBucketsResult', name='ListAllMyBucketsResult'),
}

api getService(request: GetServiceRequest, runtime: OSSUtil.RuntimeOptions): GetServiceResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/`;
  __request.headers = {
    host = OSSUtil.getHost('', @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, '', accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetServiceResponse);
  return {
    ListAllMyBucketsResult = respMap.ListAllMyBucketsResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteBucketEncryptionRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model DeleteBucketEncryptionResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteBucketEncryption(request: DeleteBucketEncryptionRequest, runtime: OSSUtil.RuntimeOptions): DeleteBucketEncryptionResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/?encryption`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteBucketTagsRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  filter: {
    tagging: string(description='tagging', name='tagging', signed='true'),
  }(description='Filter', name='Filter'),
}

model DeleteBucketTagsResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteBucketTags(request: DeleteBucketTagsRequest, runtime: OSSUtil.RuntimeOptions): DeleteBucketTagsResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketWebsiteRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketWebsiteResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  websiteConfiguration: {
    indexDocument: {
      suffix?: string(description='Suffix', name='Suffix'),
    }(description='IndexDocument', name='IndexDocument'),
    errorDocument: {
      key?: string(description='Key', name='Key'),
    }(description='ErrorDocument', name='ErrorDocument'),
    routingRules: {
      routingRule?: [
        {
          ruleNumber?: integer(description='RuleNumber', name='RuleNumber'),
          condition: {
            keyPrefixEquals?: string(description='KeyPrefixEquals', name='KeyPrefixEquals'),
            httpErrorCodeReturnedEquals?: string(description='HttpErrorCodeReturnedEquals', name='HttpErrorCodeReturnedEquals'),
            includeHeader: {
              key?: string(description='Key', name='Key'),
              equals?: string(description='Equals', name='Equals'),
            }(description='IncludeHeader', name='IncludeHeader'),
          }(description='Condition', name='Condition'),
          redirect: {
            redirectType?: string(description='RedirectType', name='RedirectType'),
            passQueryString?: boolean(description='PassQueryString', name='PassQueryString'),
            mirrorURL?: string(description='MirrorURL', name='MirrorURL'),
            mirrorPassQueryString?: boolean(description='MirrorPassQueryString', name='MirrorPassQueryString'),
            mirrorFollowRedirect?: boolean(description='MirrorFollowRedirect', name='MirrorFollowRedirect'),
            mirrorCheckMd5?: boolean(description='MirrorCheckMd5', name='MirrorCheckMd5'),
            protocol?: string(description='Protocol', name='Protocol'),
            hostName?: string(description='HostName', name='HostName'),
            httpRedirectCode?: string(description='HttpRedirectCode', name='HttpRedirectCode'),
            replaceKeyPrefixWith?: string(description='ReplaceKeyPrefixWith', name='ReplaceKeyPrefixWith'),
            replaceKeyWith?: string(description='ReplaceKeyWith', name='ReplaceKeyWith'),
            mirrorHeaders: {
              passAll?: boolean(description='PassAll', name='PassAll'),
              pass?: string(description='Pass', name='Pass'),
              remove?: string(description='Remove', name='Remove'),
              set: {
                key?: string(description='Key', name='Key'),
                value?: string(description='Value', name='Value'),
              }(description='Set', name='Set'),
            }(description='MirrorHeaders', name='MirrorHeaders'),
          }(description='Redirect', name='Redirect'),
        }
      ](description='RoutingRule', name='RoutingRule'),
    }(description='RoutingRules', name='RoutingRules'),
  }(description='WebsiteConfiguration', name='WebsiteConfiguration'),
}

api getBucketWebsite(request: GetBucketWebsiteRequest, runtime: OSSUtil.RuntimeOptions): GetBucketWebsiteResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?website`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketWebsiteResponse);
  return {
    WebsiteConfiguration = respMap.WebsiteConfiguration,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteLiveChannelRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
}

model DeleteLiveChannelResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteLiveChannel(request: DeleteLiveChannelRequest, runtime: OSSUtil.RuntimeOptions): DeleteLiveChannelResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/${request.channelName}?live`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketLocationRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketLocationResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  locationConstraint: string(description='LocationConstraint', name='LocationConstraint'),
}

api getBucketLocation(request: GetBucketLocationRequest, runtime: OSSUtil.RuntimeOptions): GetBucketLocationResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?location`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketLocationResponse);
  return {
    LocationConstraint = respMap.LocationConstraint,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model ListLiveChannelRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  filter?: {
    marker?: string(description='marker', name='marker'),
    maxKeys?: string(description='max-keys', name='max-keys'),
    prefix?: string(description='prefix', name='prefix'),
  }(description='Filter', name='Filter'),
}

model ListLiveChannelResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  listLiveChannelResult: {
    prefix?: string(description='Prefix', name='Prefix'),
    marker?: string(description='Marker', name='Marker'),
    maxKeys?: string(description='MaxKeys', name='MaxKeys'),
    isTruncated?: string(description='IsTruncated', name='IsTruncated'),
    nextMarker?: string(description='NextMarker', name='NextMarker'),
    liveChannel: {
      name?: string(description='Name', name='Name'),
      description?: string(description='Description', name='Description'),
      status?: string(description='Status', name='Status'),
      lastModified?: string(description='LastModified', name='LastModified'),
      publishUrls: {
        url?: string(description='Url', name='Url'),
      }(description='PublishUrls', name='PublishUrls'),
      playUrls: {
        url?: string(description='Url', name='Url'),
      }(description='PlayUrls', name='PlayUrls'),
    }(description='LiveChannel', name='LiveChannel'),
  }(description='ListLiveChannelResult', name='ListLiveChannelResult'),
}

api listLiveChannel(request: ListLiveChannelRequest, runtime: OSSUtil.RuntimeOptions): ListLiveChannelResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?live`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, ListLiveChannelResponse);
  return {
    ListLiveChannelResult = respMap.ListLiveChannelResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetObjectMetaRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
}

model GetObjectMetaResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  eTag: string(description='ETag', name='etag'),
  contentLength: string(description='Content-Length', name='content-length'),
  lastModified: string(description='Last-Modified', name='last-modified'),
}

api getObjectMeta(request: GetObjectMetaRequest, runtime: OSSUtil.RuntimeOptions): GetObjectMetaResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'HEAD';
  __request.pathname = `/${request.objectName}?objectMeta`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketAclRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketAclResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  accessControlPolicy: {
    owner: {
      iD?: string(description='ID', name='ID'),
      displayName?: string(description='DisplayName', name='DisplayName'),
    }(description='Owner', name='Owner'),
    accessControlList: {
      grant?: string(description='Grant', name='Grant'),
    }(description='AccessControlList', name='AccessControlList'),
  }(description='AccessControlPolicy', name='AccessControlPolicy'),
}

api getBucketAcl(request: GetBucketAclRequest, runtime: OSSUtil.RuntimeOptions): GetBucketAclResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?acl`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketAclResponse);
  return {
    AccessControlPolicy = respMap.AccessControlPolicy,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model ListPartsRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  filter: {
    uploadId: string(description='uploadId', name='uploadId', signed='true'),
    maxParts?: integer(description='max-parts', name='max-parts'),
    partNumberMarker?: integer(description='part-number-marker', name='part-number-marker'),
    encodingType?: string(description='Encoding-type', name='Encoding-type'),
  }(description='Filter', name='Filter'),
}

model ListPartsResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  listPartsResult: {
    bucket?: string(description='Bucket', name='Bucket'),
    encodingType?: string(description='EncodingType', name='EncodingType'),
    key?: string(description='Key', name='Key'),
    uploadId?: string(description='UploadId', name='UploadId'),
    partNumberMarker?: string(description='PartNumberMarker', name='PartNumberMarker'),
    nextPartNumberMarker?: string(description='NextPartNumberMarker', name='NextPartNumberMarker'),
    maxParts?: string(description='MaxParts', name='MaxParts'),
    isTruncated?: string(description='IsTruncated', name='IsTruncated'),
    part?: [
      {
        partNumber?: string(description='PartNumber', name='PartNumber'),
        lastModified?: string(description='LastModified', name='LastModified'),
        eTag?: string(description='ETag', name='ETag'),
        size?: string(description='Size', name='Size'),
      }
    ](description='Part', name='Part'),
  }(description='ListPartsResult', name='ListPartsResult'),
}

api listParts(request: ListPartsRequest, runtime: OSSUtil.RuntimeOptions): ListPartsResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, ListPartsResponse);
  return {
    ListPartsResult = respMap.ListPartsResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetLiveChannelHistoryRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
  filter?: {
    comp?: string(description='comp', name='comp', signed='true'),
  }(description='Filter', name='Filter'),
}

model GetLiveChannelHistoryResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  liveChannelHistory: {
    liveRecord?: [
      {
        startTime?: string(description='StartTime', name='StartTime'),
        endTime?: string(description='EndTime', name='EndTime'),
        remoteAddr?: string(description='RemoteAddr', name='RemoteAddr'),
      }
    ](description='LiveRecord', name='LiveRecord'),
  }(description='LiveChannelHistory', name='LiveChannelHistory'),
}

api getLiveChannelHistory(request: GetLiveChannelHistoryRequest, runtime: OSSUtil.RuntimeOptions): GetLiveChannelHistoryResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.channelName}?live`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetLiveChannelHistoryResponse);
  return {
    LiveChannelHistory = respMap.LiveChannelHistory,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  filter?: {
    delimiter?: string(description='delimiter', name='delimiter'),
    marker?: string(description='marker', name='marker'),
    maxKeys?: string(description='max-keys', name='max-keys'),
    prefix?: string(description='prefix', name='prefix'),
    encodingType?: string(description='encoding-type', name='encoding-type'),
  }(description='Filter', name='Filter'),
}

model GetBucketResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  listBucketResult: {
    name?: string(description='Name', name='Name'),
    prefix?: string(description='Prefix', name='Prefix'),
    marker?: string(description='Marker', name='Marker'),
    maxKeys?: string(description='MaxKeys', name='MaxKeys'),
    delimiter?: string(description='Delimiter', name='Delimiter'),
    isTruncated?: string(description='IsTruncated', name='IsTruncated'),
    encodingType?: string(description='EncodingType', name='EncodingType'),
    commonPrefixes?: string(description='CommonPrefixes', name='CommonPrefixes'),
    contents?: [
      {
        key?: string(description='Key', name='Key'),
        eTag?: string(description='ETag', name='ETag'),
        lastModified?: string(description='LastModified', name='LastModified'),
        size?: string(description='Size', name='Size'),
        storageClass?: string(description='StorageClass', name='StorageClass'),
        owner: {
          iD?: string(description='ID', name='ID'),
          displayName?: string(description='DisplayName', name='DisplayName'),
        }(description='Owner', name='Owner'),
      }
    ](description='Contents', name='Contents'),
  }(description='ListBucketResult', name='ListBucketResult'),
}

api getBucket(request: GetBucketRequest, runtime: OSSUtil.RuntimeOptions): GetBucketResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketResponse);
  return {
    ListBucketResult = respMap.ListBucketResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetLiveChannelInfoRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
}

model GetLiveChannelInfoResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  liveChannelConfiguration: {
    description?: string(description='Description', name='Description'),
    status?: string(description='Status', name='Status'),
    target: {
      type?: string(description='Type', name='Type'),
      fragDuration?: string(description='FragDuration', name='FragDuration'),
      fragCount?: string(description='FragCount', name='FragCount'),
      playlistName?: string(description='PlaylistName', name='PlaylistName'),
    }(description='Target', name='Target'),
  }(description='LiveChannelConfiguration', name='LiveChannelConfiguration'),
}

api getLiveChannelInfo(request: GetLiveChannelInfoRequest, runtime: OSSUtil.RuntimeOptions): GetLiveChannelInfoResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.channelName}?live`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetLiveChannelInfoResponse);
  return {
    LiveChannelConfiguration = respMap.LiveChannelConfiguration,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetLiveChannelStatRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
  filter?: {
    comp?: string(description='comp', name='comp', signed='true'),
  }(description='Filter', name='Filter'),
}

model GetLiveChannelStatResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  liveChannelStat: {
    status?: string(description='Status', name='Status'),
    connectedTime?: string(description='ConnectedTime', name='ConnectedTime'),
    remoteAddr?: string(description='RemoteAddr', name='RemoteAddr'),
    video: {
      width?: string(description='Width', name='Width'),
      height?: string(description='Height', name='Height'),
      frameRate?: string(description='FrameRate', name='FrameRate'),
      bandwidth?: string(description='Bandwidth', name='Bandwidth'),
      codec?: string(description='Codec', name='Codec'),
    }(description='Video', name='Video'),
    audio: {
      bandwidth?: string(description='Bandwidth', name='Bandwidth'),
      sampleRate?: string(description='SampleRate', name='SampleRate'),
      codec?: string(description='Codec', name='Codec'),
    }(description='Audio', name='Audio'),
  }(description='LiveChannelStat', name='LiveChannelStat'),
}

api getLiveChannelStat(request: GetLiveChannelStatRequest, runtime: OSSUtil.RuntimeOptions): GetLiveChannelStatResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.channelName}?live`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetLiveChannelStatResponse);
  return {
    LiveChannelStat = respMap.LiveChannelStat,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
}

model DeleteObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteObject(request: DeleteObjectRequest, runtime: OSSUtil.RuntimeOptions): DeleteObjectResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model AbortMultipartUploadRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  filter: {
    uploadId: string(description='uploadId', name='uploadId', signed='true'),
  }(description='Filter', name='Filter'),
}

model AbortMultipartUploadResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api abortMultipartUpload(request: AbortMultipartUploadRequest, runtime: OSSUtil.RuntimeOptions): AbortMultipartUploadResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model AppendObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  userMeta?: map[string]string(description='UserMeta', name='UserMeta'),
  body?: readable(description='body', name='body'),
  filter: {
    position: string(description='position', name='position', signed='true'),
  }(description='Filter', name='Filter'),
  header?: {
    cacheControl?: string(description='Cache-Control', name='Cache-Control'),
    contentDisposition?: string(description='Content-Disposition', name='Content-Disposition'),
    contentEncoding?: string(description='Content-Encoding', name='Content-Encoding'),
    contentMD5?: string(description='Content-MD5', name='Content-MD5'),
    expires?: string(description='Expires', name='Expires'),
    serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
    objectAcl?: string(description='x-oss-object-acl', name='x-oss-object-acl'),
    storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
    contentType?: string(description='content-type', name='content-type'),
  }(description='Header', name='Header'),
}

model AppendObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  nextAppendPosition: string(description='x-oss-next-append-position', name='x-oss-next-append-position'),
  hashCrc64ecma: string(description='x-oss-hash-crc64ecma', name='x-oss-hash-crc64ecma'),
}

api appendObject(request: AppendObjectRequest, runtime: OSSUtil.RuntimeOptions): AppendObjectResponse {
  var ctx : map[string]string = {};
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/${request.objectName}?append`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
    ...OSSUtil.parseMeta(request.userMeta, 'x-oss-meta-'),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.body = OSSUtil.inject(request.body, ctx);
  if (!Util.isUnset(request.header) && !Util.empty(request.header.contentType)) {
    __request.headers.content-type = request.header.contentType;
  } else {
    __request.headers.content-type = OSSUtil.getContentType(request.objectName);
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  if (@isEnableCrc && !Util.equalString(ctx.crc, __response.headers.x-oss-hash-crc64ecma)) {
    throw {
      code = 'CrcNotMatched',
      data = {
        clientCrc = ctx.crc,
        serverCrc = __response.headers.x-oss-hash-crc64ecma,
      },
    };
  }

  if (@isEnableMD5 && !Util.equalString(ctx.md5, __response.headers.content-md5)) {
    throw {
      code = 'MD5NotMatched',
      data = {
        clientMD5 = ctx.md5,
        serverMD5 = __response.headers.content-md5,
      },
    };
  }

  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model UploadPartCopyRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  filter: {
    partNumber: string(description='partNumber', name='partNumber', signed='true'),
    uploadId: string(description='uploadId', name='uploadId', signed='true'),
  }(description='Filter', name='Filter'),
  header: {
    copySource: string(description='x-oss-copy-source', name='x-oss-copy-source'),
    copySourceRange: string(description='x-oss-copy-source-range', name='x-oss-copy-source-range'),
    copySourceIfMatch?: string(description='x-oss-copy-source-if-match', name='x-oss-copy-source-if-match'),
    copySourceIfNoneMatch?: string(description='x-oss-copy-source-if-none-match', name='x-oss-copy-source-if-none-match'),
    copySourceIfUnmodifiedSince?: string(description='x-oss-copy-source-if-unmodified-since', name='x-oss-copy-source-if-unmodified-since'),
    copySourceIfModifiedSince?: string(description='x-oss-copy-source-if-modified-since', name='x-oss-copy-source-if-modified-since'),
  }(description='Header', name='Header'),
}

model UploadPartCopyResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  copyPartResult: {
    lastModified?: string(description='LastModified', name='LastModified'),
    eTag?: string(description='ETag', name='ETag'),
  }(description='CopyPartResult', name='CopyPartResult'),
}

api uploadPartCopy(request: UploadPartCopyRequest, runtime: OSSUtil.RuntimeOptions): UploadPartCopyResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, UploadPartCopyResponse);
  return {
    CopyPartResult = respMap.CopyPartResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetVodPlaylistRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
  filter: {
    endTime: string(description='endTime', name='endTime', signed='true'),
    startTime: string(description='startTime', name='startTime', signed='true'),
  }(description='Filter', name='Filter'),
}

model GetVodPlaylistResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api getVodPlaylist(request: GetVodPlaylistRequest, runtime: OSSUtil.RuntimeOptions): GetVodPlaylistResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.channelName}?vod`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteBucketCORSRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model DeleteBucketCORSResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteBucketCORS(request: DeleteBucketCORSRequest, runtime: OSSUtil.RuntimeOptions): DeleteBucketCORSResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/?cors`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  header?: {
    responseContentType?: string(description='response-content-type', name='response-content-type'),
    responseContentLanguage?: string(description='response-content-language', name='response-content-language'),
    responseExpires?: string(description='response-expires', name='response-expires'),
    responseCacheControl?: string(description='response-cache-control', name='response-cache-control'),
    responseContentDisposition?: string(description='response-content-disposition', name='response-content-disposition'),
    responseContentEncoding?: string(description='response-content-encoding', name='response-content-encoding'),
    range?: string(description='Range', name='Range'),
    ifModifiedSince?: string(description='If-Modified-Since', name='If-Modified-Since'),
    ifUnmodifiedSince?: string(description='If-Unmodified-Since', name='If-Unmodified-Since'),
    ifMatch?: string(description='If-Match', name='If-Match'),
    ifNoneMatch?: string(description='If-None-Match', name='If-None-Match'),
    acceptEncoding?: string(description='Accept-Encoding', name='Accept-Encoding'),
  }(description='Header', name='Header'),
}

model GetObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  objectType: string(description='x-oss-object-type', name='x-oss-object-type'),
  serverSideEncryption: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
  taggingCount: string(description='x-oss-tagging-count', name='x-oss-tagging-count'),
  restore: string(description='x-oss-restore', name='x-oss-restore'),
  body: readable(description='body', name='body'),
}

api getObject(request: GetObjectRequest, runtime: OSSUtil.RuntimeOptions): GetObjectResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    body = __response.body,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model UploadPartRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  body?: readable(description='body', name='body'),
  filter: {
    partNumber: string(description='partNumber', name='partNumber', signed='true'),
    uploadId: string(description='uploadId', name='uploadId', signed='true'),
  }(description='Filter', name='Filter'),
}

model UploadPartResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api uploadPart(request: UploadPartRequest, runtime: OSSUtil.RuntimeOptions): UploadPartResponse {
  var ctx : map[string]string = {};
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.body = OSSUtil.inject(request.body, ctx);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  if (@isEnableCrc && !Util.equalString(ctx.crc, __response.headers.x-oss-hash-crc64ecma)) {
    throw {
      code = 'CrcNotMatched',
      data = {
        clientCrc = ctx.crc,
        serverCrc = __response.headers.x-oss-hash-crc64ecma,
      },
    };
  }

  if (@isEnableMD5 && !Util.equalString(ctx.md5, __response.headers.content-md5)) {
    throw {
      code = 'MD5NotMatched',
      data = {
        clientMD5 = ctx.md5,
        serverMD5 = __response.headers.content-md5,
      },
    };
  }

  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketCORSRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketCORSResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  cORSConfiguration: {
    cORSRule?: [
      {
        maxAgeSeconds?: string(description='MaxAgeSeconds', name='MaxAgeSeconds'),
      }
    ](description='CORSRule', name='CORSRule'),
  }(description='CORSConfiguration', name='CORSConfiguration'),
}

api getBucketCORS(request: GetBucketCORSRequest, runtime: OSSUtil.RuntimeOptions): GetBucketCORSResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?cors`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketCORSResponse);
  return {
    CORSConfiguration = respMap.CORSConfiguration,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model CopyObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  destObjectName: string(description='DestObjectName', name='DestObjectName'),
  header: {
    copySource: string(description='x-oss-copy-source', name='x-oss-copy-source'),
    copySourceIfMatch?: string(description='x-oss-copy-source-if-match', name='x-oss-copy-source-if-match'),
    copySourceIfNoneMatch?: string(description='x-oss-copy-source-if-none-match', name='x-oss-copy-source-if-none-match'),
    copySourceIfUnmodifiedSince?: string(description='x-oss-copy-source-if-unmodified-since', name='x-oss-copy-source-if-unmodified-since'),
    copySourceIfModifiedSince?: string(description='x-oss-copy-source-if-modified-since', name='x-oss-copy-source-if-modified-since'),
    metadataDirective?: string(description='x-oss-metadata-directive', name='x-oss-metadata-directive'),
    serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
    serverSideEncryptionKeyId?: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
    objectAcl?: string(description='x-oss-object-acl', name='x-oss-object-acl'),
    storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
    tagging?: string(description='x-oss-tagging', name='x-oss-tagging'),
    taggingDirective?: string(description='x-oss-tagging-directive', name='x-oss-tagging-directive'),
  }(description='Header', name='Header'),
}

model CopyObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  copyObjectResult: {
    lastModified?: string(description='LastModified', name='LastModified'),
    eTag?: string(description='ETag', name='ETag'),
  }(description='CopyObjectResult', name='CopyObjectResult'),
}

api copyObject(request: CopyObjectRequest, runtime: OSSUtil.RuntimeOptions): CopyObjectResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.destObjectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  
      __request.headers.x-oss-copy-source = OSSUtil.encode(__request.headers.x-oss-copy-source, 'UrlEncode');
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, CopyObjectResponse);
  return {
    CopyObjectResult = respMap.CopyObjectResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetObjectTaggingRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
}

model GetObjectTaggingResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  tagging: {
    tagSet: {
      tag?: [
        {
          key?: string(description='Key', name='Key'),
          value?: string(description='Value', name='Value'),
        }
      ](description='Tag', name='Tag'),
    }(description='TagSet', name='TagSet'),
  }(description='Tagging', name='Tagging'),
}

api getObjectTagging(request: GetObjectTaggingRequest, runtime: OSSUtil.RuntimeOptions): GetObjectTaggingResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.objectName}?tagging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetObjectTaggingResponse);
  return {
    Tagging = respMap.Tagging,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteBucketLifecycleRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model DeleteBucketLifecycleResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteBucketLifecycle(request: DeleteBucketLifecycleRequest, runtime: OSSUtil.RuntimeOptions): DeleteBucketLifecycleResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/?lifecycle`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteBucketLoggingRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model DeleteBucketLoggingResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteBucketLogging(request: DeleteBucketLoggingRequest, runtime: OSSUtil.RuntimeOptions): DeleteBucketLoggingResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/?logging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteBucketWebsiteRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model DeleteBucketWebsiteResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteBucketWebsite(request: DeleteBucketWebsiteRequest, runtime: OSSUtil.RuntimeOptions): DeleteBucketWebsiteResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/?website`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetSymlinkRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
}

model GetSymlinkResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  symlinkTarget: string(description='x-oss-symlink-target', name='x-oss-symlink-target'),
}

api getSymlink(request: GetSymlinkRequest, runtime: OSSUtil.RuntimeOptions): GetSymlinkResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.objectName}?symlink`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketLifecycleRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketLifecycleResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  lifecycleConfiguration: {
    rule?: [
      {
        iD?: string(description='ID', name='ID'),
        prefix?: string(description='Prefix', name='Prefix'),
        status?: string(description='Status', name='Status'),
        expiration: {
          days?: integer(description='Days', name='Days'),
          createdBeforeDate?: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
        }(description='Expiration', name='Expiration'),
        transition: {
          days?: integer(description='Days', name='Days'),
          storageClass?: string(description='StorageClass', name='StorageClass'),
        }(description='Transition', name='Transition'),
        abortMultipartUpload: {
          days?: integer(description='Days', name='Days'),
          createdBeforeDate?: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
        }(description='AbortMultipartUpload', name='AbortMultipartUpload'),
        tag: {
          key?: string(description='Key', name='Key'),
          value?: string(description='Value', name='Value'),
        }(description='Tag', name='Tag'),
      }
    ](description='Rule', name='Rule'),
  }(description='LifecycleConfiguration', name='LifecycleConfiguration'),
}

api getBucketLifecycle(request: GetBucketLifecycleRequest, runtime: OSSUtil.RuntimeOptions): GetBucketLifecycleResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?lifecycle`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketLifecycleResponse);
  return {
    LifecycleConfiguration = respMap.LifecycleConfiguration,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutSymlinkRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  header: {
    symlinkTarget: string(description='x-oss-symlink-target', name='x-oss-symlink-target'),
    storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
  }(description='Header', name='Header'),
}

model PutSymlinkResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putSymlink(request: PutSymlinkRequest, runtime: OSSUtil.RuntimeOptions): PutSymlinkResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.objectName}?symlink`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketRefererRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketRefererResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  refererConfiguration: {
    allowEmptyReferer?: boolean(description='AllowEmptyReferer', name='AllowEmptyReferer'),
    refererList: {
      referer?: [ string ](description='Referer', name='Referer'),
    }(description='RefererList', name='RefererList'),
  }(description='RefererConfiguration', name='RefererConfiguration'),
}

api getBucketReferer(request: GetBucketRefererRequest, runtime: OSSUtil.RuntimeOptions): GetBucketRefererResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?referer`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketRefererResponse);
  return {
    RefererConfiguration = respMap.RefererConfiguration,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model CallbackRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model CallbackResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api callback(request: CallbackRequest, runtime: OSSUtil.RuntimeOptions): CallbackResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketLoggingRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketLoggingResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  bucketLoggingStatus: {
    loggingEnabled: {
      targetBucket?: string(description='TargetBucket', name='TargetBucket'),
      targetPrefix?: string(description='TargetPrefix', name='TargetPrefix'),
    }(description='LoggingEnabled', name='LoggingEnabled'),
  }(description='BucketLoggingStatus', name='BucketLoggingStatus'),
}

api getBucketLogging(request: GetBucketLoggingRequest, runtime: OSSUtil.RuntimeOptions): GetBucketLoggingResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?logging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketLoggingResponse);
  return {
    BucketLoggingStatus = respMap.BucketLoggingStatus,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutObjectAclRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  header: {
    objectAcl: string(description='x-oss-object-acl', name='x-oss-object-acl'),
  }(description='Header', name='Header'),
}

model PutObjectAclResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putObjectAcl(request: PutObjectAclRequest, runtime: OSSUtil.RuntimeOptions): PutObjectAclResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.objectName}?acl`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetBucketInfoRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model GetBucketInfoResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  bucketInfo: {
    bucket: {
      creationDate?: string(description='CreationDate', name='CreationDate'),
      extranetEndpoint?: string(description='ExtranetEndpoint', name='ExtranetEndpoint'),
      intranetEndpoint?: string(description='IntranetEndpoint', name='IntranetEndpoint'),
      location?: string(description='Location', name='Location'),
      name?: string(description='Name', name='Name'),
      dataRedundancyType?: string(description='DataRedundancyType', name='DataRedundancyType'),
      storageClass?: string(description='StorageClass', name='StorageClass'),
      comment?: string(description='Comment', name='Comment'),
      owner: {
        iD?: string(description='ID', name='ID'),
        displayName?: string(description='DisplayName', name='DisplayName'),
      }(description='Owner', name='Owner'),
      accessControlList: {
        grant?: string(description='Grant', name='Grant'),
      }(description='AccessControlList', name='AccessControlList'),
    }(description='Bucket', name='Bucket'),
  }(description='BucketInfo', name='BucketInfo'),
}

api getBucketInfo(request: GetBucketInfoRequest, runtime: OSSUtil.RuntimeOptions): GetBucketInfoResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/?bucketInfo`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetBucketInfoResponse);
  return {
    BucketInfo = respMap.BucketInfo,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutLiveChannelStatusRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
  filter: {
    status: string(description='status', name='status', signed='true'),
  }(description='Filter', name='Filter'),
}

model PutLiveChannelStatusResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putLiveChannelStatus(request: PutLiveChannelStatusRequest, runtime: OSSUtil.RuntimeOptions): PutLiveChannelStatusResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.channelName}?live`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model InitiateMultipartUploadRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  filter?: {
    encodingType?: string(description='encoding-type', name='encoding-type'),
  }(description='Filter', name='Filter'),
  header?: {
    cacheControl?: string(description='Cache-Control', name='Cache-Control'),
    contentDisposition?: string(description='Content-Disposition', name='Content-Disposition'),
    contentEncoding?: string(description='Content-Encoding', name='Content-Encoding'),
    expires?: string(description='Expires', name='Expires'),
    serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
    serverSideEncryptionKeyId?: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
    storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
    tagging?: string(description='x-oss-tagging', name='x-oss-tagging'),
    contentType?: string(description='content-type', name='content-type'),
  }(description='Header', name='Header'),
}

model InitiateMultipartUploadResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  initiateMultipartUploadResult: {
    bucket?: string(description='Bucket', name='Bucket'),
    key?: string(description='Key', name='Key'),
    uploadId?: string(description='UploadId', name='UploadId'),
  }(description='InitiateMultipartUploadResult', name='InitiateMultipartUploadResult'),
}

api initiateMultipartUpload(request: InitiateMultipartUploadRequest, runtime: OSSUtil.RuntimeOptions): InitiateMultipartUploadResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/${request.objectName}?uploads`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  if (!Util.isUnset(request.header) && !Util.empty(request.header.contentType)) {
    __request.headers.content-type = request.header.contentType;
  } else {
    __request.headers.content-type = OSSUtil.getContentType(request.objectName);
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, InitiateMultipartUploadResponse);
  return {
    InitiateMultipartUploadResult = respMap.InitiateMultipartUploadResult,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model OptionObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  header: {
    origin: string(description='Origin', name='Origin'),
    accessControlRequestMethod: string(description='Access-Control-Request-Method', name='Access-Control-Request-Method'),
    accessControlRequestHeaders: string(description='Access-Control-Request-Headers', name='Access-Control-Request-Headers'),
  }(description='Header', name='Header'),
}

model OptionObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  accessControlAllowOrigin: string(description='Access-Control-Allow-Origin', name='access-control-allow-origin'),
  accessControlAllowMethods: string(description='Access-Control-Allow-Methods', name='access-control-allow-methods'),
  accessControlAllowHeaders: string(description='Access-Control-Allow-Headers', name='access-control-allow-headers'),
  accessControlExposeHeaders: string(description='Access-Control-Expose-Headers', name='access-control-expose-headers'),
  accessControlMaxAge: string(description='Access-Control-Max-Age', name='access-control-max-age'),
}

api optionObject(request: OptionObjectRequest, runtime: OSSUtil.RuntimeOptions): OptionObjectResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'OPTIONS';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PostVodPlaylistRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  channelName: string(description='ChannelName', name='ChannelName'),
  playlistName: string(description='PlaylistName', name='PlaylistName'),
  filter: {
    endTime: string(description='endTime', name='endTime', signed='true'),
    startTime: string(description='startTime', name='startTime', signed='true'),
  }(description='Filter', name='Filter'),
}

model PostVodPlaylistResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api postVodPlaylist(request: PostVodPlaylistRequest, runtime: OSSUtil.RuntimeOptions): PostVodPlaylistResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/${request.channelName}/${request.playlistName}?vod`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.query = Util.stringifyMapValue(request.filter);
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PostObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  header: {
    accessKeyId: string(description='OSSAccessKeyId', name='OSSAccessKeyId'),
    policy: string(description='policy', name='policy'),
    signature: string(description='Signature', name='Signature'),
    successActionStatus?: string(description='success_action_status', name='success_action_status'),
    file: FileForm.FileField,
    key: string(description='key', name='key'),
    userMeta?: map[string]string(description='UserMeta', name='UserMeta')
  }(description='header', name='header')
}

model PostObjectResponse = {
  postResponse: {
    bucket: string(description='Bucket', name='Bucket'),
    eTag: string(description='ETag', name='ETag'),
    location: string(description='Location', name='Location'),
  }(description='PostResponse', name='PostResponse'),
}

api postObject(request: PostObjectRequest, runtime: OSSUtil.RuntimeOptions): PostObjectResponse {
  var boundary = FileForm.getBoundary();
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  __request.headers.content-type = `multipart/form-data; boundary=${boundary}`;
  var form = {
    OSSAccessKeyId = request.header.accessKeyId,
    policy = request.header.policy,
    Signature = request.header.signature,
    key = request.header.key,
    success_action_status = request.header.successActionStatus,
    file = request.header.file,
    ...OSSUtil.toMeta(request.header.userMeta, 'x-oss-meta-'),
  };
  __request.body = FileForm.toFileForm(form, boundary);
} returns {
  var respMap : object = null;
  var bodyStr = Util.readAsString(__response.body);
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }

  respMap = XML.parseXml(bodyStr, PostObjectResponse);
  return {
    ...respMap,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false)
}

model HeadObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  header?: {
    ifModifiedSince?: string(description='If-Modified-Since', name='If-Modified-Since'),
    ifUnmodifiedSince?: string(description='If-Unmodified-Since', name='If-Unmodified-Since'),
    ifMatch?: string(description='If-Match', name='If-Match'),
    ifNoneMatch?: string(description='If-None-Match', name='If-None-Match'),
  }(description='Header', name='Header'),
}

model HeadObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  userMeta: map[string]string(description='usermeta', name='usermeta'),
  serverSideEncryption: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
  serverSideEncryptionKeyId: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
  storageClass: string(description='x-oss-storage-class', name='x-oss-storage-class'),
  objectType: string(description='x-oss-object-type', name='x-oss-object-type'),
  nextAppendPosition: string(description='x-oss-next-append-position', name='x-oss-next-append-position'),
  hashCrc64ecma: string(description='x-oss-hash-crc64ecma', name='x-oss-hash-crc64ecma'),
  expiration: string(description='x-oss-expiration', name='x-oss-expiration'),
  restore: string(description='x-oss-restore', name='x-oss-restore'),
  processStatus: string(description='x-oss-process-status', name='x-oss-process-status'),
  requestCharged: string(description='x-oss-request-charged', name='x-oss-request-charged'),
  contentMd5: string(description='Content-Md5', name='content-md5'),
  lastModified: string(description='Last-Modified', name='last-modified'),
  accessControlAllowOrigin: string(description='Access-Control-Allow-Origin', name='access-control-allow-origin'),
  accessControlAllowMethods: string(description='Access-Control-Allow-Methods', name='access-control-allow-methods'),
  accessControlMaxAge: string(description='Access-Control-Max-Age', name='access-control-max-age'),
  accessControlAllowHeaders: string(description='Access-Control-Allow-Headers', name='access-control-allow-headers'),
  accessControlExposeHeaders: string(description='Access-Control-Expose-Headers', name='access-control-expose-headers'),
  taggingCount: string(description='x-oss-tagging-count', name='x-oss-tagging-count'),
}

api headObject(request: HeadObjectRequest, runtime: OSSUtil.RuntimeOptions): HeadObjectResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'HEAD';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    usermeta = OSSUtil.toMeta(__response.headers, 'x-oss-meta-'),
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteObjectTaggingRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
}

model DeleteObjectTaggingResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteObjectTagging(request: DeleteObjectTaggingRequest, runtime: OSSUtil.RuntimeOptions): DeleteObjectTaggingResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/${request.objectName}?tagging`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model RestoreObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
}

model RestoreObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api restoreObject(request: RestoreObjectRequest, runtime: OSSUtil.RuntimeOptions): RestoreObjectResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'POST';
  __request.pathname = `/${request.objectName}?restore`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model GetObjectAclRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
}

model GetObjectAclResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  accessControlPolicy: {
    owner: {
      iD?: string(description='ID', name='ID'),
      displayName?: string(description='DisplayName', name='DisplayName'),
    }(description='Owner', name='Owner'),
    accessControlList: {
      grant?: string(description='Grant', name='Grant'),
    }(description='AccessControlList', name='AccessControlList'),
  }(description='AccessControlPolicy', name='AccessControlPolicy'),
}

api getObjectAcl(request: GetObjectAclRequest, runtime: OSSUtil.RuntimeOptions): GetObjectAclResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'GET';
  __request.pathname = `/${request.objectName}?acl`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  bodyStr = Util.readAsString(__response.body);
  respMap = XML.parseXml(bodyStr, GetObjectAclResponse);
  return {
    AccessControlPolicy = respMap.AccessControlPolicy,
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutBucketAclRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  header: {
    acl: string(description='x-oss-acl', name='x-oss-acl'),
  }(description='Header', name='Header'),
}

model PutBucketAclResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api putBucketAcl(request: PutBucketAclRequest, runtime: OSSUtil.RuntimeOptions): PutBucketAclResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/?acl`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model DeleteBucketRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
}

model DeleteBucketResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
}

api deleteBucket(request: DeleteBucketRequest, runtime: OSSUtil.RuntimeOptions): DeleteBucketResponse {
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'DELETE';
  __request.pathname = `/`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

model PutObjectRequest = {
  bucketName: string(description='BucketName', name='BucketName', pattern='[a-zA-Z0-9-_]+'),
  objectName: string(description='ObjectName', name='ObjectName'),
  userMeta?: map[string]string(description='UserMeta', name='UserMeta'),
  body?: readable(description='body', name='body'),
  header?: {
    authorization?: string(description='Authorization', name='Authorization'),
    cacheControl?: string(description='Cache-Control', name='Cache-Control'),
    contentDisposition?: string(description='Content-Disposition', name='Content-Disposition'),
    contentEncoding?: string(description='Content-Encoding', name='Content-Encoding'),
    contentMD5?: string(description='Content-MD5', name='Content-MD5'),
    contentLength?: string(description='Content-Length', name='Content-Length'),
    eTag?: string(description='CETag', name='CETag'),
    expires?: string(description='Expires', name='Expires'),
    serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
    serverSideEncryptionKeyId?: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
    objectAcl?: string(description='x-oss-object-acl', name='x-oss-object-acl'),
    storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
    tagging?: string(description='x-oss-tagging', name='x-oss-tagging'),
    contentType?: string(description='content-type', name='content-type'),
  }(description='Header', name='Header'),
}

model PutObjectResponse = {
  requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  hashCrc64ecma: string(description='x-oss-hash-crc64ecma', name='x-oss-hash-crc64ecma'),
  serverTime: string(description='x-oss-server-time', name='x-oss-server-time'),
  bucketVersion: string(description='x-oss-bucket-version', name='x-oss-bucket-version'),
}

api putObject(request: PutObjectRequest, runtime: OSSUtil.RuntimeOptions): PutObjectResponse {
  var ctx : map[string]string = {};
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var token = @credential.getSecurityToken();
  __request.protocol = @protocol;
  __request.method = 'PUT';
  __request.pathname = `/${request.objectName}`;
  __request.headers = {
    host = OSSUtil.getHost(request.bucketName, @regionId, @endpoint, @hostModel),
    date = Util.getDateUTCString(),
    user-agent = getUserAgent(),
    ...Util.stringifyMapValue(request.header),
    ...OSSUtil.parseMeta(request.userMeta, 'x-oss-meta-'),
  };
  if (!Util.empty(token)) {
    __request.headers.x-oss-security-token = token;
  }
  __request.body = OSSUtil.inject(request.body, ctx);
  if (!Util.isUnset(request.header) && !Util.empty(request.header.contentType)) {
    __request.headers.content-type = request.header.contentType;
  } else {
    __request.headers.content-type = OSSUtil.getContentType(request.objectName);
  }
  __request.headers.authorization = OSSUtil.getSignature(__request, request.bucketName, accessKeyId, accessKeySecret, @signatureVersion, @addtionalHeaders);
} returns {
  var respMap : object = null;
  var bodyStr : string = null;
  if (Util.is4xx(__response.statusCode) || Util.is5xx(__response.statusCode)) {
    bodyStr = Util.readAsString(__response.body);
    respMap = OSSUtil.getErrMessage(bodyStr);
    throw {
      code = respMap.Code,
      message = respMap.Message,
      data = {
        httpCode = __response.statusCode,
        requestId = respMap.RequestId,
        hostId = respMap.HostId,
      }
    };
  }
  if (@isEnableCrc && !Util.equalString(ctx.crc, __response.headers.x-oss-hash-crc64ecma)) {
    throw {
      code = 'CrcNotMatched',
      data = {
        clientCrc = ctx.crc,
        serverCrc = __response.headers.x-oss-hash-crc64ecma,
      },
    };
  }

  if (@isEnableMD5 && !Util.equalString(ctx.md5, __response.headers.content-md5)) {
    throw {
      code = 'MD5NotMatched',
      data = {
        clientMD5 = ctx.md5,
        serverMD5 = __response.headers.content-md5,
      },
    };
  }

  return {
    ...__response.headers,
  };
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  localAddr = Util.defaultString(runtime.localAddr, @localAddr),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  socks5Proxy = Util.defaultString(runtime.socks5Proxy, @socks5Proxy),
  socks5NetWork = Util.defaultString(runtime.socks5NetWork, @socks5NetWork),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = defaultAny(runtime.ignoreSSL, false),
}

function setUserAgent(userAgent: string): void {
  @userAgent = userAgent;
}

function appendUserAgent(userAgent: string): void {
  @userAgent = `${@userAgent} ${userAgent}`;
}

function getUserAgent(): string {
  var userAgent =  Util.getUserAgent(@userAgent);
  return userAgent;
}

async function getAccessKeyId(): string{
  if (Util.isUnset(@credential)) {
    return '';
  }
  var accessKeyId = @credential.getAccessKeyId();
  return accessKeyId;
}

async function getAccessKeySecret(): string{
  if (Util.isUnset(@credential)) {
    return '';
  }
  var secret = @credential.getAccessKeySecret();
  return secret;
}

/**
 * If inputValue is not null, return it or return defaultValue
 * @param inputValue  users input value
 * @param defaultValue default value
 * @return the final result
 */
static function defaultAny(inputValue: any, defaultValue: any): any {
  if (Util.isUnset(inputValue)) {
    return defaultValue;
  }
  return inputValue;
}
