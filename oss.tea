module Client {

  type @endpoint = string
  type @regionId = string
  type @hostModel = string
  type @protocol = string
  type @readTimeout = number
  type @connectTimeout = number
  type @signatureVersion = string
  type @addtionalHeaders = [ string ]
  type @localAddr = string
  type @httpProxy = string
  type @httpsProxy = string
  type @noProxy = string
  type @socks5Proxy = string
  type @socks5NetWork = string
  type @maxIdleConns = number
  type @logger = any

  type @getDate = (): string
  type @getSignatureV1 = ($Request, string, string): string
  type @getSignatureV2 = ($Request, string, string, [ string ]): string
  type @readAsString = async ($Response): string
  type @parseXml = (string, class): object
  type @getErrMessage = (string): object
  type @default = (string, string): string
  type @defaultNumber = (number, number): number
  type @toBody = (any): string
  type @isFail = ($Response): boolean
  type @toQuery = (object): map[string]string
  type @toMeta = (object, string): map[string]string
  type @parseMeta = (object, string): map[string]string
  type @toXML = (any): string
  type @getContentType = (string): string
  type @notNull = (any): boolean
  type @getContentMD5 = (string): string
  type @encode = (string, string): string
  type @readAsStream = ($Response): readable
  type @toHeader = (object): map[string]string
  type @equal = (string, string): boolean
  type @getSecurityToken = async (): string
  type @empty = (string): boolean
  type @getAccessKeyID = async (): string
  type @getAccessKeySecret = async (): string
  type @listToString = ([ string ], string): string
  type @ifListEmpty = ([ string ]): boolean
  type @getUserAgent = (): string
  type @inject = (readable, map[string]string): readable

  prop version = '2019-05-17';

  model RuntimeObject {
    autoretry?: boolean(description='autoretry', name='autoretry'),
    ignoreSSL?: boolean(description='ignoreSSL', name='ignoreSSL'),
    maxAttempts?: number(description='max attempts', name='maxAttempts'),
    backoffPolicy?: string(description='backoff policy', name='backoffPolicy'),
    backoffPeriod?: number(description='backoff period', name='backoffPeriod'),
    readTimeout?: number(description='read timeout', name='readTimeout'),
    connectTimeout?: number(description='connect timeout', name='connectTimeout'),
    localAddr?: string(description='local addr', name='localAddr'),
    httpProxy?: string(description='http proxy', name='httpProxy'),
    httpsProxy?: string(description='https proxy', name='httpsProxy'),
    noProxy?: string(description='no proxy', name='noProxy'),
    maxIdleConns?: number(description='max idle conns', name='maxIdleConns'),
    socks5Proxy?: string(description='socks5 proxy', name='socks5Proxy'),
    socks5NetWork?: string(description='socks5 NetWork', name='socks5NetWork'),
    md5Threshold?: int64(description='MD5Threshold', name='MD5Threshold'),
    uploadLimitSpeed?: number(description='upload limit speed', name='uploadLimitSpeed'),
    listener?: any(description='listener', name='listener'),
  }

  model Config {
    accessKeyId?: string,
    accessKeySecret?: string,
    type: string,
    securityToken: string,
    endpoint: string,
    protocol: string,
    regionId: string,
    userAgent: string,
    hostModel: string,
    signatureVersion: string,
    isEnableMD5: boolean,
    isEnableCrc: boolean,
    readTimeout: number,
    connectTimeout: number,
    localAddr: string,
    httpProxy: string,
    httpsProxy: string,
    noProxy: string,
    socks5Proxy: string,
    socks5NetWork: string,
    maxIdleConns: number,
    addtionalHeaders: [ string ],
  }

  init(config: Config);

  function getHost(bucketName: string): string {
    if (@empty(@regionId)) {
      @regionId = `cn-hangzhou`;
    }
    if (@empty(@endpoint)) {
      @endpoint = `oss-${@regionId}.aliyuncs.com`;
    }
    if (@empty(bucketName)) {
      return @endpoint;
    }
    var host : string = null;
    if (@equal(@hostModel, 'ip')) {
      host = `${@endpoint}/${bucketName}`;
    } else if (@equal(@hostModel, 'cname')) {
      host = @endpoint;
    } else {
      host = `${bucketName}.${@endpoint}`;
    }
    return host;
  }

  async function getSignature(request: $Request, bucketName: string): string {
    var accessKeyId = @getAccessKeyID();
    var accessKeySecret = @getAccessKeySecret();
    if (@equal(@signatureVersion, 'V2')) {
      if (@ifListEmpty(@addtionalHeaders)) {
        return `OSS2 AccessKeyId:${accessKeyId},Signature:${@getSignatureV2(request, bucketName, accessKeySecret, @addtionalHeaders)}`;
      } else {
        return `OSS2 AccessKeyId:${accessKeyId},AdditionalHeaders:${@listToString(@addtionalHeaders, ";")},Signature:${@getSignatureV2(request, bucketName, accessKeySecret, @addtionalHeaders)}`;
      }
    } else {
      return `OSS ${accessKeyId}:${@getSignatureV1(request, bucketName, accessKeySecret)}`;
    }
  }

  model PutBucketLifecycleRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      lifecycleConfiguration: {
        rule: [
          {
            expiration: {
              days: integer(description='Days', name='Days'),
              createdBeforeDate: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
            }(description='Expiration', name='Expiration'),
            transition: {
              days: integer(description='Days', name='Days'),
              storageClass: string(description='StorageClass', name='StorageClass'),
            }(description='Transition', name='Transition'),
            abortMultipartUpload: {
              days: integer(description='Days', name='Days'),
              createdBeforeDate: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
            }(description='AbortMultipartUpload', name='AbortMultipartUpload'),
            tag: {
              key: string(description='Key', name='Key'),
              value: string(description='Value', name='Value'),
            }(description='Tag', name='Tag'),
            iD: string(description='ID', name='ID'),
            prefix: string(description='Prefix', name='Prefix'),
            status: string(description='Status', name='Status'),
          }
        ](description='Rule', name='Rule'),
      }(description='LifecycleConfiguration', name='LifecycleConfiguration'),
    }(description='Body', name='Body'),
  }

  model PutBucketLifecycleResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketLifecycle(request: PutBucketLifecycleRequest, runtime: RuntimeObject): PutBucketLifecycleResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?lifecycle`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteMultipleObjectsRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      delete: {
        object: [
          {
            key: string(description='Key', name='Key'),
          }
        ](description='Object', name='Object'),
        quiet: string(description='Quiet', name='Quiet'),
      }(description='Delete', name='Delete'),
    }(description='Body', name='Body'),
    header: {
      encodingType?: string(description='Encoding-type', name='Encoding-type'),
      contentLength: string(description='Content-Length', name='Content-Length'),
      contentMD5: string(description='Content-MD5', name='Content-MD5'),
    }(description='Header', name='Header'),
  }

  model DeleteMultipleObjectsResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    deleteResult: {
      quiet: string(description='Quiet', name='Quiet'),
      encodingType: string(description='EncodingType', name='EncodingType'),
      deleted: [
        {
          key: string(description='Key', name='Key'),
        }
      ](description='Deleted', name='Deleted'),
    }(description='DeleteResult', name='DeleteResult'),
  }

  api deleteMultipleObjects(request: DeleteMultipleObjectsRequest, runtime: RuntimeObject): DeleteMultipleObjectsResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'POST';
    pathname = `/?delete`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    if (@notNull(request.header) && !@empty(request.header.contentMD5)) {
      headers.content-md5 = request.header.contentMD5;
    } else {
      headers.content-md5 = @getContentMD5(reqBody);
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, DeleteMultipleObjectsResponse);
    return {
      DeleteResult = respMap.DeleteResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketRefererRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      refererConfiguration: {
        refererList: {
          referer: [ string ](description='Referer', name='Referer'),
        }(description='RefererList', name='RefererList'),
        allowEmptyReferer: boolean(description='AllowEmptyReferer', name='AllowEmptyReferer'),
      }(description='RefererConfiguration', name='RefererConfiguration'),
    }(description='Body', name='Body'),
  }

  model PutBucketRefererResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketReferer(request: PutBucketRefererRequest, runtime: RuntimeObject): PutBucketRefererResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?referer`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketWebsiteRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      websiteConfiguration: {
        indexDocument: {
          suffix: string(description='Suffix', name='Suffix'),
        }(description='IndexDocument', name='IndexDocument'),
        errorDocument: {
          key: string(description='Key', name='Key'),
        }(description='ErrorDocument', name='ErrorDocument'),
        routingRules: {
          routingRule: [
            {
              condition: {
                includeHeader: {
                  key: string(description='Key', name='Key'),
                  equals: string(description='Equals', name='Equals'),
                }(description='IncludeHeader', name='IncludeHeader'),
                keyPrefixEquals: string(description='KeyPrefixEquals', name='KeyPrefixEquals'),
                httpErrorCodeReturnedEquals: string(description='HttpErrorCodeReturnedEquals', name='HttpErrorCodeReturnedEquals'),
              }(description='Condition', name='Condition'),
              redirect: {
                mirrorHeaders: {
                  set: {
                    key: string(description='Key', name='Key'),
                    value: string(description='Value', name='Value'),
                  }(description='Set', name='Set'),
                  passAll: boolean(description='PassAll', name='PassAll'),
                  pass: string(description='Pass', name='Pass'),
                  remove: string(description='Remove', name='Remove'),
                }(description='MirrorHeaders', name='MirrorHeaders'),
                redirectType: string(description='RedirectType', name='RedirectType'),
                passQueryString: boolean(description='PassQueryString', name='PassQueryString'),
                mirrorURL: string(description='MirrorURL', name='MirrorURL'),
                mirrorPassQueryString: boolean(description='MirrorPassQueryString', name='MirrorPassQueryString'),
                mirrorFollowRedirect: boolean(description='MirrorFollowRedirect', name='MirrorFollowRedirect'),
                mirrorCheckMd5: boolean(description='MirrorCheckMd5', name='MirrorCheckMd5'),
                protocol: string(description='Protocol', name='Protocol'),
                hostName: string(description='HostName', name='HostName'),
                httpRedirectCode: string(description='HttpRedirectCode', name='HttpRedirectCode'),
                replaceKeyPrefixWith: string(description='ReplaceKeyPrefixWith', name='ReplaceKeyPrefixWith'),
                replaceKeyWith: string(description='ReplaceKeyWith', name='ReplaceKeyWith'),
              }(description='Redirect', name='Redirect'),
              ruleNumber: integer(description='RuleNumber', name='RuleNumber'),
            }
          ](description='RoutingRule', name='RoutingRule'),
        }(description='RoutingRules', name='RoutingRules'),
      }(description='WebsiteConfiguration', name='WebsiteConfiguration'),
    }(description='Body', name='Body'),
  }

  model PutBucketWebsiteResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketWebsite(request: PutBucketWebsiteRequest, runtime: RuntimeObject): PutBucketWebsiteResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?website`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model CompleteMultipartUploadRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    filter: {
      uploadId: string(description='uploadId', name='uploadId', signed='true'),
      encodingType?: string(description='Encoding-type', name='Encoding-type'),
    }(description='Filter', name='Filter'),
    body?: {
      completeMultipartUpload: {
        part: [
          {
            partNumber: string(description='PartNumber', name='PartNumber'),
            eTag: string(description='ETag', name='ETag'),
          }
        ](description='Part', name='Part'),
      }(description='CompleteMultipartUpload', name='CompleteMultipartUpload'),
    }(description='Body', name='Body'),
  }

  model CompleteMultipartUploadResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    completeMultipartUploadResult: {
      bucket: string(description='Bucket', name='Bucket'),
      eTag: string(description='ETag', name='ETag'),
      location: string(description='Location', name='Location'),
      key: string(description='Key', name='Key'),
      encodingType: string(description='EncodingType', name='EncodingType'),
    }(description='CompleteMultipartUploadResult', name='CompleteMultipartUploadResult'),
  }

  api completeMultipartUpload(request: CompleteMultipartUploadRequest, runtime: RuntimeObject): CompleteMultipartUploadResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'POST';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, CompleteMultipartUploadResponse);
    return {
      CompleteMultipartUploadResult = respMap.CompleteMultipartUploadResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketLoggingRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      bucketLoggingStatus: {
        loggingEnabled: {
          targetBucket: string(description='TargetBucket', name='TargetBucket'),
          targetPrefix: string(description='TargetPrefix', name='TargetPrefix'),
        }(description='LoggingEnabled', name='LoggingEnabled'),
      }(description='BucketLoggingStatus', name='BucketLoggingStatus'),
    }(description='Body', name='Body'),
  }

  model PutBucketLoggingResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketLogging(request: PutBucketLoggingRequest, runtime: RuntimeObject): PutBucketLoggingResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?logging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketRequestPaymentRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      requestPaymentConfiguration: {
        payer: string(description='Payer', name='Payer'),
      }(description='RequestPaymentConfiguration', name='RequestPaymentConfiguration'),
    }(description='Body', name='Body'),
  }

  model PutBucketRequestPaymentResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketRequestPayment(request: PutBucketRequestPaymentRequest, runtime: RuntimeObject): PutBucketRequestPaymentResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?requestPayment`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketEncryptionRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      serverSideEncryptionRule: {
        applyServerSideEncryptionByDefault: {
          sSEAlgorithm: string(description='SSEAlgorithm', name='SSEAlgorithm'),
          kMSMasterKeyID: string(description='KMSMasterKeyID', name='KMSMasterKeyID'),
        }(description='ApplyServerSideEncryptionByDefault', name='ApplyServerSideEncryptionByDefault'),
      }(description='ServerSideEncryptionRule', name='ServerSideEncryptionRule'),
    }(description='Body', name='Body'),
  }

  model PutBucketEncryptionResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketEncryption(request: PutBucketEncryptionRequest, runtime: RuntimeObject): PutBucketEncryptionResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?encryption`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutLiveChannelRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
    body?: {
      liveChannelConfiguration: {
        target: {
          type: string(description='Type', name='Type'),
          fragDuration: string(description='FragDuration', name='FragDuration'),
          fragCount: string(description='FragCount', name='FragCount'),
          playlistName: string(description='PlaylistName', name='PlaylistName'),
        }(description='Target', name='Target'),
        snapshot: {
          roleName: string(description='RoleName', name='RoleName'),
          destBucket: string(description='DestBucket', name='DestBucket'),
          notifyTopic: string(description='NotifyTopic', name='NotifyTopic'),
          interval: string(description='Interval', name='Interval'),
        }(description='Snapshot', name='Snapshot'),
        description: string(description='Description', name='Description'),
        status: string(description='Status', name='Status'),
      }(description='LiveChannelConfiguration', name='LiveChannelConfiguration'),
    }(description='Body', name='Body'),
  }

  model PutLiveChannelResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    createLiveChannelResult: {
      publishUrls: {
        url: string(description='Url', name='Url'),
      }(description='PublishUrls', name='PublishUrls'),
      playUrls: {
        url: string(description='Url', name='Url'),
      }(description='PlayUrls', name='PlayUrls'),
    }(description='CreateLiveChannelResult', name='CreateLiveChannelResult'),
  }

  api putLiveChannel(request: PutLiveChannelRequest, runtime: RuntimeObject): PutLiveChannelResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.channelName}?live`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, PutLiveChannelResponse);
    return {
      CreateLiveChannelResult = respMap.CreateLiveChannelResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketTagsRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      tagging: {
        tagSet: {
          tag: [
            {
              key: string(description='Key', name='Key'),
              value: string(description='Value', name='Value'),
            }
          ](description='Tag', name='Tag'),
        }(description='TagSet', name='TagSet'),
      }(description='Tagging', name='Tagging'),
    }(description='Body', name='Body'),
  }

  model PutBucketTagsResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketTags(request: PutBucketTagsRequest, runtime: RuntimeObject): PutBucketTagsResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?tagging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutObjectTaggingRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    body?: {
      tagging: {
        tagSet: {
          tag: [
            {
              key: string(description='Key', name='Key'),
              value: string(description='Value', name='Value'),
            }
          ](description='Tag', name='Tag'),
        }(description='TagSet', name='TagSet'),
      }(description='Tagging', name='Tagging'),
    }(description='Body', name='Body'),
  }

  model PutObjectTaggingResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putObjectTagging(request: PutObjectTaggingRequest, runtime: RuntimeObject): PutObjectTaggingResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.objectName}?tagging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model SelectObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    filter: {
      porcess: string(description='x-oss-process', name='x-oss-process'),
    }(description='Filter', name='Filter'),
    body?: {
      selectRequest: {
        inputSerialization: {
          cSV: {
            fileHeaderInfo: string(description='FileHeaderInfo', name='FileHeaderInfo'),
            recordDelimiter: string(description='RecordDelimiter', name='RecordDelimiter'),
            fieldDelimiter: string(description='FieldDelimiter', name='FieldDelimiter'),
            quoteCharacter: string(description='QuoteCharacter', name='QuoteCharacter'),
            commentCharacter: string(description='CommentCharacter', name='CommentCharacter'),
            range: string(description='Range', name='Range'),
          }(description='CSV', name='CSV'),
          compressionType: string(description='CompressionType', name='CompressionType'),
        }(description='InputSerialization', name='InputSerialization'),
        outputSerialization: {
          cSV: {
            recordDelimiter: string(description='RecordDelimiter', name='RecordDelimiter'),
            fieldDelimiter: string(description='FieldDelimiter', name='FieldDelimiter'),
          }(description='CSV', name='CSV'),
          keepAllColumns: string(description='KeepAllColumns', name='KeepAllColumns'),
          outputRawData: string(description='OutputRawData', name='OutputRawData'),
          enablePayloadCrc: string(description='EnablePayloadCrc', name='EnablePayloadCrc'),
          outputHeader: string(description='OutputHeader', name='OutputHeader'),
        }(description='OutputSerialization', name='OutputSerialization'),
        options: {
          skipPartialDataRecord: string(description='SkipPartialDataRecord', name='SkipPartialDataRecord'),
          maxSkippedRecordsAllowed: string(description='MaxSkippedRecordsAllowed', name='MaxSkippedRecordsAllowed'),
        }(description='Options', name='Options'),
        expression: string(description='Expression', name='Expression'),
      }(description='SelectRequest', name='SelectRequest'),
    }(description='Body', name='Body'),
  }

  model SelectObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api selectObject(request: SelectObjectRequest, runtime: RuntimeObject): SelectObjectResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'POST';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketCORSRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      cORSConfiguration: {
        cORSRule: [
          {
            allowedOrigin: [ string ](description='AllowedOrigin', name='AllowedOrigin'),
            allowedMethod: [ string ](description='AllowedMethod', name='AllowedMethod'),
            allowedHeader: [ string ](description='AllowedHeader', name='AllowedHeader'),
            exposeHeader: [ string ](description='ExposeHeader', name='ExposeHeader'),
            maxAgeSeconds: string(description='MaxAgeSeconds', name='MaxAgeSeconds'),
          }
        ](description='CORSRule', name='CORSRule'),
      }(description='CORSConfiguration', name='CORSConfiguration'),
    }(description='Body', name='Body'),
  }

  model PutBucketCORSResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketCORS(request: PutBucketCORSRequest, runtime: RuntimeObject): PutBucketCORSResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?cors`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    body?: {
      createBucketConfiguration: {
        storageClass: string(description='StorageClass', name='StorageClass'),
        dataRedundancyType: string(description='DataRedundancyType', name='DataRedundancyType'),
      }(description='CreateBucketConfiguration', name='CreateBucketConfiguration'),
    }(description='Body', name='Body'),
    header?: {
      acl?: string(description='x-oss-acl', name='x-oss-acl'),
    }(description='Header', name='Header'),
  }

  model PutBucketResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucket(request: PutBucketRequest, runtime: RuntimeObject): PutBucketResponse {
    var token = @getSecurityToken();
    var reqBody = @toXML(request.body);
    protocol = @protocol;
    method = 'PUT';
    pathname = `/`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = reqBody;
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model ListMultipartUploadsRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    filter?: {
      delimiter?: string(description='delimiter', name='delimiter'),
      maxUploads?: string(description='max-uploads', name='max-uploads'),
      keyMarker?: string(description='key-marker', name='key-marker'),
      prefix?: string(description='prefix', name='prefix'),
      uploadIdMarker?: string(description='upload-id-marker', name='upload-id-marker'),
      encodingType?: string(description='encoding-type', name='encoding-type'),
    }(description='Filter', name='Filter'),
  }

  model ListMultipartUploadsResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    listMultipartUploadsResult: {
      bucket: string(description='Bucket', name='Bucket'),
      encodingType: string(description='EncodingType', name='EncodingType'),
      keyMarker: string(description='KeyMarker', name='KeyMarker'),
      uploadIdMarker: string(description='UploadIdMarker', name='UploadIdMarker'),
      nextKeyMarker: string(description='NextKeyMarker', name='NextKeyMarker'),
      nextUploadIdMarker: string(description='NextUploadIdMarker', name='NextUploadIdMarker'),
      delimiter: string(description='Delimiter', name='Delimiter'),
      maxUploads: string(description='MaxUploads', name='MaxUploads'),
      isTruncated: string(description='IsTruncated', name='IsTruncated'),
      upload: [
        {
          key: string(description='Key', name='Key'),
          uploadId: string(description='UploadId', name='UploadId'),
          initiated: string(description='Initiated', name='Initiated'),
        }
      ](description='Upload', name='Upload'),
    }(description='ListMultipartUploadsResult', name='ListMultipartUploadsResult'),
  }

  api listMultipartUploads(request: ListMultipartUploadsRequest, runtime: RuntimeObject): ListMultipartUploadsResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?uploads`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, ListMultipartUploadsResponse);
    return {
      ListMultipartUploadsResult = respMap.ListMultipartUploadsResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketRequestPaymentRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketRequestPaymentResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    requestPaymentConfiguration: {
      payer: string(description='Payer', name='Payer'),
    }(description='RequestPaymentConfiguration', name='RequestPaymentConfiguration'),
  }

  api getBucketRequestPayment(request: GetBucketRequestPaymentRequest, runtime: RuntimeObject): GetBucketRequestPaymentResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?requestPayment`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketRequestPaymentResponse);
    return {
      RequestPaymentConfiguration = respMap.RequestPaymentConfiguration,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketEncryptionRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketEncryptionResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    serverSideEncryptionRule: {
      applyServerSideEncryptionByDefault: {
        sSEAlgorithm: string(description='SSEAlgorithm', name='SSEAlgorithm'),
        kMSMasterKeyID: string(description='KMSMasterKeyID', name='KMSMasterKeyID'),
      }(description='ApplyServerSideEncryptionByDefault', name='ApplyServerSideEncryptionByDefault'),
    }(description='ServerSideEncryptionRule', name='ServerSideEncryptionRule'),
  }

  api getBucketEncryption(request: GetBucketEncryptionRequest, runtime: RuntimeObject): GetBucketEncryptionResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?encryption`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketEncryptionResponse);
    return {
      ServerSideEncryptionRule = respMap.ServerSideEncryptionRule,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketTagsRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketTagsResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    tagging: {
      tagSet: {
        tag: [
          {
            key: string(description='Key', name='Key'),
            value: string(description='Value', name='Value'),
          }
        ](description='Tag', name='Tag'),
      }(description='TagSet', name='TagSet'),
    }(description='Tagging', name='Tagging'),
  }

  api getBucketTags(request: GetBucketTagsRequest, runtime: RuntimeObject): GetBucketTagsResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?tagging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketTagsResponse);
    return {
      Tagging = respMap.Tagging,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetServiceRequest = {
    filter?: {
      prefix?: string(description='prefix', name='prefix'),
      marker?: string(description='marker', name='marker'),
      maxKeys?: string(description='max-keys', name='max-keys'),
    }(description='Filter', name='Filter'),
  }

  model GetServiceResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    listAllMyBucketsResult: {
      prefix: string(description='Prefix', name='Prefix'),
      marker: string(description='Marker', name='Marker'),
      maxKeys: string(description='MaxKeys', name='MaxKeys'),
      isTruncated: string(description='IsTruncated', name='IsTruncated'),
      nextMarker: string(description='NextMarker', name='NextMarker'),
      owner: {
        iD: string(description='ID', name='ID'),
        displayName: string(description='DisplayName', name='DisplayName'),
      }(description='Owner', name='Owner'),
      buckets: {
        bucket: [
          {
            name: string(description='Name', name='Name'),
            createDate: string(description='CreateDate', name='CreateDate'),
            location: string(description='Location', name='Location'),
            extranetEndpoint: string(description='ExtranetEndpoint', name='ExtranetEndpoint'),
            intranetEndpoint: string(description='IntranetEndpoint', name='IntranetEndpoint'),
            storageClass: string(description='StorageClass', name='StorageClass'),
          }
        ](description='Bucket', name='Bucket'),
      }(description='Buckets', name='Buckets'),
    }(description='ListAllMyBucketsResult', name='ListAllMyBucketsResult'),
  }

  api getService(request: GetServiceRequest, runtime: RuntimeObject): GetServiceResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/`;
    headers = {
      host = getHost(''),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, '');
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetServiceResponse);
    return {
      ListAllMyBucketsResult = respMap.ListAllMyBucketsResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteBucketEncryptionRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model DeleteBucketEncryptionResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteBucketEncryption(request: DeleteBucketEncryptionRequest, runtime: RuntimeObject): DeleteBucketEncryptionResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/?encryption`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteBucketTagsRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    filter: {
      tagging: string(description='tagging', name='tagging', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model DeleteBucketTagsResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteBucketTags(request: DeleteBucketTagsRequest, runtime: RuntimeObject): DeleteBucketTagsResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketWebsiteRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketWebsiteResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    websiteConfiguration: {
      indexDocument: {
        suffix: string(description='Suffix', name='Suffix'),
      }(description='IndexDocument', name='IndexDocument'),
      errorDocument: {
        key: string(description='Key', name='Key'),
      }(description='ErrorDocument', name='ErrorDocument'),
      routingRules: {
        routingRule: [
          {
            ruleNumber: integer(description='RuleNumber', name='RuleNumber'),
            condition: {
              keyPrefixEquals: string(description='KeyPrefixEquals', name='KeyPrefixEquals'),
              httpErrorCodeReturnedEquals: string(description='HttpErrorCodeReturnedEquals', name='HttpErrorCodeReturnedEquals'),
              includeHeader: {
                key: string(description='Key', name='Key'),
                equals: string(description='Equals', name='Equals'),
              }(description='IncludeHeader', name='IncludeHeader'),
            }(description='Condition', name='Condition'),
            redirect: {
              redirectType: string(description='RedirectType', name='RedirectType'),
              passQueryString: boolean(description='PassQueryString', name='PassQueryString'),
              mirrorURL: string(description='MirrorURL', name='MirrorURL'),
              mirrorPassQueryString: boolean(description='MirrorPassQueryString', name='MirrorPassQueryString'),
              mirrorFollowRedirect: boolean(description='MirrorFollowRedirect', name='MirrorFollowRedirect'),
              mirrorCheckMd5: boolean(description='MirrorCheckMd5', name='MirrorCheckMd5'),
              protocol: string(description='Protocol', name='Protocol'),
              hostName: string(description='HostName', name='HostName'),
              httpRedirectCode: string(description='HttpRedirectCode', name='HttpRedirectCode'),
              replaceKeyPrefixWith: string(description='ReplaceKeyPrefixWith', name='ReplaceKeyPrefixWith'),
              replaceKeyWith: string(description='ReplaceKeyWith', name='ReplaceKeyWith'),
              mirrorHeaders: {
                passAll: boolean(description='PassAll', name='PassAll'),
                pass: string(description='Pass', name='Pass'),
                remove: string(description='Remove', name='Remove'),
                set: {
                  key: string(description='Key', name='Key'),
                  value: string(description='Value', name='Value'),
                }(description='Set', name='Set'),
              }(description='MirrorHeaders', name='MirrorHeaders'),
            }(description='Redirect', name='Redirect'),
          }
        ](description='RoutingRule', name='RoutingRule'),
      }(description='RoutingRules', name='RoutingRules'),
    }(description='WebsiteConfiguration', name='WebsiteConfiguration'),
  }

  api getBucketWebsite(request: GetBucketWebsiteRequest, runtime: RuntimeObject): GetBucketWebsiteResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?website`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketWebsiteResponse);
    return {
      WebsiteConfiguration = respMap.WebsiteConfiguration,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteLiveChannelRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
  }

  model DeleteLiveChannelResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteLiveChannel(request: DeleteLiveChannelRequest, runtime: RuntimeObject): DeleteLiveChannelResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/${request.channelName}?live`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketLocationRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketLocationResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    locationConstraint: string(description='LocationConstraint', name='LocationConstraint'),
  }

  api getBucketLocation(request: GetBucketLocationRequest, runtime: RuntimeObject): GetBucketLocationResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?location`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketLocationResponse);
    return {
      LocationConstraint = respMap.LocationConstraint,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model ListLiveChannelRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    filter?: {
      marker?: string(description='marker', name='marker'),
      maxKeys?: string(description='max-keys', name='max-keys'),
      prefix?: string(description='prefix', name='prefix'),
    }(description='Filter', name='Filter'),
  }

  model ListLiveChannelResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    listLiveChannelResult: {
      prefix: string(description='Prefix', name='Prefix'),
      marker: string(description='Marker', name='Marker'),
      maxKeys: string(description='MaxKeys', name='MaxKeys'),
      isTruncated: string(description='IsTruncated', name='IsTruncated'),
      nextMarker: string(description='NextMarker', name='NextMarker'),
      liveChannel: {
        name: string(description='Name', name='Name'),
        description: string(description='Description', name='Description'),
        status: string(description='Status', name='Status'),
        lastModified: string(description='LastModified', name='LastModified'),
        publishUrls: {
          url: string(description='Url', name='Url'),
        }(description='PublishUrls', name='PublishUrls'),
        playUrls: {
          url: string(description='Url', name='Url'),
        }(description='PlayUrls', name='PlayUrls'),
      }(description='LiveChannel', name='LiveChannel'),
    }(description='ListLiveChannelResult', name='ListLiveChannelResult'),
  }

  api listLiveChannel(request: ListLiveChannelRequest, runtime: RuntimeObject): ListLiveChannelResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?live`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, ListLiveChannelResponse);
    return {
      ListLiveChannelResult = respMap.ListLiveChannelResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetObjectMetaRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
  }

  model GetObjectMetaResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    eTag: string(description='ETag', name='etag'),
    contentLength: string(description='Content-Length', name='content-length'),
    lastModified: string(description='Last-Modified', name='last-modified'),
  }

  api getObjectMeta(request: GetObjectMetaRequest, runtime: RuntimeObject): GetObjectMetaResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'HEAD';
    pathname = `/${request.objectName}?objectMeta`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketAclRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketAclResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    accessControlPolicy: {
      owner: {
        iD: string(description='ID', name='ID'),
        displayName: string(description='DisplayName', name='DisplayName'),
      }(description='Owner', name='Owner'),
      accessControlList: {
        grant: string(description='Grant', name='Grant'),
      }(description='AccessControlList', name='AccessControlList'),
    }(description='AccessControlPolicy', name='AccessControlPolicy'),
  }

  api getBucketAcl(request: GetBucketAclRequest, runtime: RuntimeObject): GetBucketAclResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?acl`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketAclResponse);
    return {
      AccessControlPolicy = respMap.AccessControlPolicy,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model ListPartsRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    filter: {
      uploadId: string(description='uploadId', name='uploadId', signed='true'),
      maxParts?: integer(description='max-parts', name='max-parts'),
      partNumberMarker?: integer(description='part-number-marker', name='part-number-marker'),
      encodingType?: string(description='Encoding-type', name='Encoding-type'),
    }(description='Filter', name='Filter'),
  }

  model ListPartsResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    listPartsResult: {
      bucket: string(description='Bucket', name='Bucket'),
      encodingType: string(description='EncodingType', name='EncodingType'),
      key: string(description='Key', name='Key'),
      uploadId: string(description='UploadId', name='UploadId'),
      partNumberMarker: string(description='PartNumberMarker', name='PartNumberMarker'),
      nextPartNumberMarker: string(description='NextPartNumberMarker', name='NextPartNumberMarker'),
      maxParts: string(description='MaxParts', name='MaxParts'),
      isTruncated: string(description='IsTruncated', name='IsTruncated'),
      part: [
        {
          partNumber: string(description='PartNumber', name='PartNumber'),
          lastModified: string(description='LastModified', name='LastModified'),
          eTag: string(description='ETag', name='ETag'),
          size: string(description='Size', name='Size'),
        }
      ](description='Part', name='Part'),
    }(description='ListPartsResult', name='ListPartsResult'),
  }

  api listParts(request: ListPartsRequest, runtime: RuntimeObject): ListPartsResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, ListPartsResponse);
    return {
      ListPartsResult = respMap.ListPartsResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetLiveChannelHistoryRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
    filter?: {
      comp?: string(description='comp', name='comp', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model GetLiveChannelHistoryResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    liveChannelHistory: {
      liveRecord: [
        {
          startTime: string(description='StartTime', name='StartTime'),
          endTime: string(description='EndTime', name='EndTime'),
          remoteAddr: string(description='RemoteAddr', name='RemoteAddr'),
        }
      ](description='LiveRecord', name='LiveRecord'),
    }(description='LiveChannelHistory', name='LiveChannelHistory'),
  }

  api getLiveChannelHistory(request: GetLiveChannelHistoryRequest, runtime: RuntimeObject): GetLiveChannelHistoryResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.channelName}?live`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetLiveChannelHistoryResponse);
    return {
      LiveChannelHistory = respMap.LiveChannelHistory,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    filter?: {
      delimiter?: string(description='delimiter', name='delimiter'),
      marker?: string(description='marker', name='marker'),
      maxKeys?: string(description='max-keys', name='max-keys'),
      prefix?: string(description='prefix', name='prefix'),
      encodingType?: string(description='encoding-type', name='encoding-type'),
    }(description='Filter', name='Filter'),
  }

  model GetBucketResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    listBucketResult: {
      name: string(description='Name', name='Name'),
      prefix: string(description='Prefix', name='Prefix'),
      marker: string(description='Marker', name='Marker'),
      maxKeys: string(description='MaxKeys', name='MaxKeys'),
      delimiter: string(description='Delimiter', name='Delimiter'),
      isTruncated: string(description='IsTruncated', name='IsTruncated'),
      encodingType: string(description='EncodingType', name='EncodingType'),
      commonPrefixes: string(description='CommonPrefixes', name='CommonPrefixes'),
      contents: [
        {
          key: string(description='Key', name='Key'),
          eTag: string(description='ETag', name='ETag'),
          lastModified: string(description='LastModified', name='LastModified'),
          size: string(description='Size', name='Size'),
          storageClass: string(description='StorageClass', name='StorageClass'),
          owner: {
            iD: string(description='ID', name='ID'),
            displayName: string(description='DisplayName', name='DisplayName'),
          }(description='Owner', name='Owner'),
        }
      ](description='Contents', name='Contents'),
    }(description='ListBucketResult', name='ListBucketResult'),
  }

  api getBucket(request: GetBucketRequest, runtime: RuntimeObject): GetBucketResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketResponse);
    return {
      ListBucketResult = respMap.ListBucketResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetLiveChannelInfoRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
  }

  model GetLiveChannelInfoResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    liveChannelConfiguration: {
      description: string(description='Description', name='Description'),
      status: string(description='Status', name='Status'),
      target: {
        type: string(description='Type', name='Type'),
        fragDuration: string(description='FragDuration', name='FragDuration'),
        fragCount: string(description='FragCount', name='FragCount'),
        playlistName: string(description='PlaylistName', name='PlaylistName'),
      }(description='Target', name='Target'),
    }(description='LiveChannelConfiguration', name='LiveChannelConfiguration'),
  }

  api getLiveChannelInfo(request: GetLiveChannelInfoRequest, runtime: RuntimeObject): GetLiveChannelInfoResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.channelName}?live`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetLiveChannelInfoResponse);
    return {
      LiveChannelConfiguration = respMap.LiveChannelConfiguration,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetLiveChannelStatRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
    filter?: {
      comp?: string(description='comp', name='comp', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model GetLiveChannelStatResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    liveChannelStat: {
      status: string(description='Status', name='Status'),
      connectedTime: string(description='ConnectedTime', name='ConnectedTime'),
      remoteAddr: string(description='RemoteAddr', name='RemoteAddr'),
      video: {
        width: string(description='Width', name='Width'),
        height: string(description='Height', name='Height'),
        frameRate: string(description='FrameRate', name='FrameRate'),
        bandwidth: string(description='Bandwidth', name='Bandwidth'),
        codec: string(description='Codec', name='Codec'),
      }(description='Video', name='Video'),
      audio: {
        bandwidth: string(description='Bandwidth', name='Bandwidth'),
        sampleRate: string(description='SampleRate', name='SampleRate'),
        codec: string(description='Codec', name='Codec'),
      }(description='Audio', name='Audio'),
    }(description='LiveChannelStat', name='LiveChannelStat'),
  }

  api getLiveChannelStat(request: GetLiveChannelStatRequest, runtime: RuntimeObject): GetLiveChannelStatResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.channelName}?live`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetLiveChannelStatResponse);
    return {
      LiveChannelStat = respMap.LiveChannelStat,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
  }

  model DeleteObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteObject(request: DeleteObjectRequest, runtime: RuntimeObject): DeleteObjectResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model AbortMultipartUploadRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    filter: {
      uploadId: string(description='uploadId', name='uploadId', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model AbortMultipartUploadResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api abortMultipartUpload(request: AbortMultipartUploadRequest, runtime: RuntimeObject): AbortMultipartUploadResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model AppendObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    userMeta?: map[string]string(description='UserMeta', name='UserMeta'),
    body?: readable(description='body', name='body'),
    filter: {
      position: string(description='position', name='position', signed='true'),
    }(description='Filter', name='Filter'),
    header?: {
      cacheControl?: string(description='Cache-Control', name='Cache-Control'),
      contentDisposition?: string(description='Content-Disposition', name='Content-Disposition'),
      contentEncoding?: string(description='Content-Encoding', name='Content-Encoding'),
      contentMD5?: string(description='Content-MD5', name='Content-MD5'),
      expires?: string(description='Expires', name='Expires'),
      serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
      objectAcl?: string(description='x-oss-object-acl', name='x-oss-object-acl'),
      storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
      contentType?: string(description='content-type', name='content-type'),
    }(description='Header', name='Header'),
  }

  model AppendObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    nextAppendPosition: string(description='x-oss-next-append-position', name='x-oss-next-append-position'),
    hashCrc64ecma: string(description='x-oss-hash-crc64ecma', name='x-oss-hash-crc64ecma'),
  }

  api appendObject(request: AppendObjectRequest, runtime: RuntimeObject): AppendObjectResponse {
    var ref : map[string]string = null;
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'POST';
    pathname = `/${request.objectName}?append`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
      ...@parseMeta(request.userMeta, 'x-oss-meta-'),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    body = @inject(request.body, ref);
    if (@notNull(request.header) && !@empty(request.header.contentType)) {
      headers.content-type = request.header.contentType;
    } else {
      headers.content-type = @getContentType(request.objectName);
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    if (!@equal(ref.crc, __response.headers.x-oss-hash-crc64ecma)) {
      throw {
        code = 'CrcNotMatched',
        data = {
          clientCrc = ref.crc,
          serverCrc = __response.headers.x-oss-hash-crc64ecma,
        },
      };
    }

    if (!@equal(ref.md5, __response.headers.content-md5)) {
      throw {
        code = 'MD5NotMatched',
        data = {
          clientMD5 = ref.md5,
          serverMD5 = __response.headers.content-md5,
        },
      };
    }

    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model UploadPartCopyRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    filter: {
      partNumber: string(description='partNumber', name='partNumber', signed='true'),
      uploadId: string(description='uploadId', name='uploadId', signed='true'),
    }(description='Filter', name='Filter'),
    header: {
      copySource: string(description='x-oss-copy-source', name='x-oss-copy-source'),
      copySourceRange: string(description='x-oss-copy-source-range', name='x-oss-copy-source-range'),
      copySourceIfMatch?: string(description='x-oss-copy-source-if-match', name='x-oss-copy-source-if-match'),
      copySourceIfNoneMatch?: string(description='x-oss-copy-source-if-none-match', name='x-oss-copy-source-if-none-match'),
      copySourceIfUnmodifiedSince?: string(description='x-oss-copy-source-if-unmodified-since', name='x-oss-copy-source-if-unmodified-since'),
      copySourceIfModifiedSince?: string(description='x-oss-copy-source-if-modified-since', name='x-oss-copy-source-if-modified-since'),
    }(description='Header', name='Header'),
  }

  model UploadPartCopyResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    copyPartResult: {
      lastModified: string(description='LastModified', name='LastModified'),
      eTag: string(description='ETag', name='ETag'),
    }(description='CopyPartResult', name='CopyPartResult'),
  }

  api uploadPartCopy(request: UploadPartCopyRequest, runtime: RuntimeObject): UploadPartCopyResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, UploadPartCopyResponse);
    return {
      CopyPartResult = respMap.CopyPartResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetVodPlaylistRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
    filter: {
      endTime: string(description='endTime', name='endTime', signed='true'),
      startTime: string(description='startTime', name='startTime', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model GetVodPlaylistResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api getVodPlaylist(request: GetVodPlaylistRequest, runtime: RuntimeObject): GetVodPlaylistResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.channelName}?vod`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteBucketCORSRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model DeleteBucketCORSResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteBucketCORS(request: DeleteBucketCORSRequest, runtime: RuntimeObject): DeleteBucketCORSResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/?cors`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    header?: {
      responseContentType?: string(description='response-content-type', name='response-content-type'),
      responseContentLanguage?: string(description='response-content-language', name='response-content-language'),
      responseExpires?: string(description='response-expires', name='response-expires'),
      responseCacheControl?: string(description='response-cache-control', name='response-cache-control'),
      responseContentDisposition?: string(description='response-content-disposition', name='response-content-disposition'),
      responseContentEncoding?: string(description='response-content-encoding', name='response-content-encoding'),
      range?: string(description='Range', name='Range'),
      ifModifiedSince?: string(description='If-Modified-Since', name='If-Modified-Since'),
      ifUnmodifiedSince?: string(description='If-Unmodified-Since', name='If-Unmodified-Since'),
      ifMatch?: string(description='If-Match', name='If-Match'),
      ifNoneMatch?: string(description='If-None-Match', name='If-None-Match'),
      acceptEncoding?: string(description='Accept-Encoding', name='Accept-Encoding'),
    }(description='Header', name='Header'),
  }

  model GetObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    objectType: string(description='x-oss-object-type', name='x-oss-object-type'),
    serverSideEncryption: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
    taggingCount: string(description='x-oss-tagging-count', name='x-oss-tagging-count'),
    restore: string(description='x-oss-restore', name='x-oss-restore'),
    body: readable(description='body', name='body'),
  }

  api getObject(request: GetObjectRequest, runtime: RuntimeObject): GetObjectResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      body = @readAsStream(__response),
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model UploadPartRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    body?: readable(description='body', name='body'),
    filter: {
      partNumber: string(description='partNumber', name='partNumber', signed='true'),
      uploadId: string(description='uploadId', name='uploadId', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model UploadPartResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api uploadPart(request: UploadPartRequest, runtime: RuntimeObject): UploadPartResponse {
    var ref : map[string]string = null;
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    body = @inject(request.body, ref);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    if (!@equal(ref.crc, __response.headers.x-oss-hash-crc64ecma)) {
      throw {
        code = 'CrcNotMatched',
        data = {
          clientCrc = ref.crc,
          serverCrc = __response.headers.x-oss-hash-crc64ecma,
        },
      };
    }

    if (!@equal(ref.md5, __response.headers.content-md5)) {
      throw {
        code = 'MD5NotMatched',
        data = {
          clientMD5 = ref.md5,
          serverMD5 = __response.headers.content-md5,
        },
      };
    }

    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketCORSRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketCORSResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    cORSConfiguration: {
      cORSRule: [
        {
          maxAgeSeconds: string(description='MaxAgeSeconds', name='MaxAgeSeconds'),
        }
      ](description='CORSRule', name='CORSRule'),
    }(description='CORSConfiguration', name='CORSConfiguration'),
  }

  api getBucketCORS(request: GetBucketCORSRequest, runtime: RuntimeObject): GetBucketCORSResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?cors`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketCORSResponse);
    return {
      CORSConfiguration = respMap.CORSConfiguration,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model CopyObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    destObjectName: string(description='DestObjectName', name='DestObjectName'),
    header: {
      copySource: string(description='x-oss-copy-source', name='x-oss-copy-source'),
      copySourceIfMatch?: string(description='x-oss-copy-source-if-match', name='x-oss-copy-source-if-match'),
      copySourceIfNoneMatch?: string(description='x-oss-copy-source-if-none-match', name='x-oss-copy-source-if-none-match'),
      copySourceIfUnmodifiedSince?: string(description='x-oss-copy-source-if-unmodified-since', name='x-oss-copy-source-if-unmodified-since'),
      copySourceIfModifiedSince?: string(description='x-oss-copy-source-if-modified-since', name='x-oss-copy-source-if-modified-since'),
      metadataDirective?: string(description='x-oss-metadata-directive', name='x-oss-metadata-directive'),
      serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
      serverSideEncryptionKeyId?: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
      objectAcl?: string(description='x-oss-object-acl', name='x-oss-object-acl'),
      storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
      tagging?: string(description='x-oss-tagging', name='x-oss-tagging'),
      taggingDirective?: string(description='x-oss-tagging-directive', name='x-oss-tagging-directive'),
    }(description='Header', name='Header'),
  }

  model CopyObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    copyObjectResult: {
      lastModified: string(description='LastModified', name='LastModified'),
      eTag: string(description='ETag', name='ETag'),
    }(description='CopyObjectResult', name='CopyObjectResult'),
  }

  api copyObject(request: CopyObjectRequest, runtime: RuntimeObject): CopyObjectResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.destObjectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    
      headers.x-oss-copy-source = @encode(__request.headers.x-oss-copy-source, 'UrlEncode');
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, CopyObjectResponse);
    return {
      CopyObjectResult = respMap.CopyObjectResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetObjectTaggingRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
  }

  model GetObjectTaggingResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    tagging: {
      tagSet: {
        tag: [
          {
            key: string(description='Key', name='Key'),
            value: string(description='Value', name='Value'),
          }
        ](description='Tag', name='Tag'),
      }(description='TagSet', name='TagSet'),
    }(description='Tagging', name='Tagging'),
  }

  api getObjectTagging(request: GetObjectTaggingRequest, runtime: RuntimeObject): GetObjectTaggingResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.objectName}?tagging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetObjectTaggingResponse);
    return {
      Tagging = respMap.Tagging,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteBucketLifecycleRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model DeleteBucketLifecycleResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteBucketLifecycle(request: DeleteBucketLifecycleRequest, runtime: RuntimeObject): DeleteBucketLifecycleResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/?lifecycle`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteBucketLoggingRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model DeleteBucketLoggingResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteBucketLogging(request: DeleteBucketLoggingRequest, runtime: RuntimeObject): DeleteBucketLoggingResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/?logging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteBucketWebsiteRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model DeleteBucketWebsiteResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteBucketWebsite(request: DeleteBucketWebsiteRequest, runtime: RuntimeObject): DeleteBucketWebsiteResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/?website`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetSymlinkRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
  }

  model GetSymlinkResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    symlinkTarget: string(description='x-oss-symlink-target', name='x-oss-symlink-target'),
  }

  api getSymlink(request: GetSymlinkRequest, runtime: RuntimeObject): GetSymlinkResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.objectName}?symlink`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketLifecycleRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketLifecycleResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    lifecycleConfiguration: {
      rule: [
        {
          iD: string(description='ID', name='ID'),
          prefix: string(description='Prefix', name='Prefix'),
          status: string(description='Status', name='Status'),
          expiration: {
            days: integer(description='Days', name='Days'),
            createdBeforeDate: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
          }(description='Expiration', name='Expiration'),
          transition: {
            days: integer(description='Days', name='Days'),
            storageClass: string(description='StorageClass', name='StorageClass'),
          }(description='Transition', name='Transition'),
          abortMultipartUpload: {
            days: integer(description='Days', name='Days'),
            createdBeforeDate: string(description='CreatedBeforeDate', name='CreatedBeforeDate'),
          }(description='AbortMultipartUpload', name='AbortMultipartUpload'),
          tag: {
            key: string(description='Key', name='Key'),
            value: string(description='Value', name='Value'),
          }(description='Tag', name='Tag'),
        }
      ](description='Rule', name='Rule'),
    }(description='LifecycleConfiguration', name='LifecycleConfiguration'),
  }

  api getBucketLifecycle(request: GetBucketLifecycleRequest, runtime: RuntimeObject): GetBucketLifecycleResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?lifecycle`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketLifecycleResponse);
    return {
      LifecycleConfiguration = respMap.LifecycleConfiguration,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutSymlinkRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    header: {
      symlinkTarget: string(description='x-oss-symlink-target', name='x-oss-symlink-target'),
      storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
    }(description='Header', name='Header'),
  }

  model PutSymlinkResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putSymlink(request: PutSymlinkRequest, runtime: RuntimeObject): PutSymlinkResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.objectName}?symlink`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketRefererRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketRefererResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    refererConfiguration: {
      allowEmptyReferer: boolean(description='AllowEmptyReferer', name='AllowEmptyReferer'),
      refererList: {
        referer: [ string ](description='Referer', name='Referer'),
      }(description='RefererList', name='RefererList'),
    }(description='RefererConfiguration', name='RefererConfiguration'),
  }

  api getBucketReferer(request: GetBucketRefererRequest, runtime: RuntimeObject): GetBucketRefererResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?referer`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketRefererResponse);
    return {
      RefererConfiguration = respMap.RefererConfiguration,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model CallbackRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model CallbackResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api callback(request: CallbackRequest, runtime: RuntimeObject): CallbackResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketLoggingRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketLoggingResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    bucketLoggingStatus: {
      loggingEnabled: {
        targetBucket: string(description='TargetBucket', name='TargetBucket'),
        targetPrefix: string(description='TargetPrefix', name='TargetPrefix'),
      }(description='LoggingEnabled', name='LoggingEnabled'),
    }(description='BucketLoggingStatus', name='BucketLoggingStatus'),
  }

  api getBucketLogging(request: GetBucketLoggingRequest, runtime: RuntimeObject): GetBucketLoggingResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?logging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketLoggingResponse);
    return {
      BucketLoggingStatus = respMap.BucketLoggingStatus,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutObjectAclRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    header: {
      objectAcl: string(description='x-oss-object-acl', name='x-oss-object-acl'),
    }(description='Header', name='Header'),
  }

  model PutObjectAclResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putObjectAcl(request: PutObjectAclRequest, runtime: RuntimeObject): PutObjectAclResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.objectName}?acl`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetBucketInfoRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model GetBucketInfoResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    bucketInfo: {
      bucket: {
        creationDate: string(description='CreationDate', name='CreationDate'),
        extranetEndpoint: string(description='ExtranetEndpoint', name='ExtranetEndpoint'),
        intranetEndpoint: string(description='IntranetEndpoint', name='IntranetEndpoint'),
        location: string(description='Location', name='Location'),
        name: string(description='Name', name='Name'),
        dataRedundancyType: string(description='DataRedundancyType', name='DataRedundancyType'),
        storageClass: string(description='StorageClass', name='StorageClass'),
        comment: string(description='Comment', name='Comment'),
        owner: {
          iD: string(description='ID', name='ID'),
          displayName: string(description='DisplayName', name='DisplayName'),
        }(description='Owner', name='Owner'),
        accessControlList: {
          grant: string(description='Grant', name='Grant'),
        }(description='AccessControlList', name='AccessControlList'),
      }(description='Bucket', name='Bucket'),
    }(description='BucketInfo', name='BucketInfo'),
  }

  api getBucketInfo(request: GetBucketInfoRequest, runtime: RuntimeObject): GetBucketInfoResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/?bucketInfo`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetBucketInfoResponse);
    return {
      BucketInfo = respMap.BucketInfo,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutLiveChannelStatusRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
    filter: {
      status: string(description='status', name='status', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model PutLiveChannelStatusResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putLiveChannelStatus(request: PutLiveChannelStatusRequest, runtime: RuntimeObject): PutLiveChannelStatusResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.channelName}?live`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model InitiateMultipartUploadRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    filter?: {
      encodingType?: string(description='encoding-type', name='encoding-type'),
    }(description='Filter', name='Filter'),
    header?: {
      cacheControl?: string(description='Cache-Control', name='Cache-Control'),
      contentDisposition?: string(description='Content-Disposition', name='Content-Disposition'),
      contentEncoding?: string(description='Content-Encoding', name='Content-Encoding'),
      expires?: string(description='Expires', name='Expires'),
      serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
      serverSideEncryptionKeyId?: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
      storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
      tagging?: string(description='x-oss-tagging', name='x-oss-tagging'),
      contentType?: string(description='content-type', name='content-type'),
    }(description='Header', name='Header'),
  }

  model InitiateMultipartUploadResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    initiateMultipartUploadResult: {
      bucket: string(description='Bucket', name='Bucket'),
      key: string(description='Key', name='Key'),
      uploadId: string(description='UploadId', name='UploadId'),
    }(description='InitiateMultipartUploadResult', name='InitiateMultipartUploadResult'),
  }

  api initiateMultipartUpload(request: InitiateMultipartUploadRequest, runtime: RuntimeObject): InitiateMultipartUploadResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'POST';
    pathname = `/${request.objectName}?uploads`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    if (@notNull(request.header) && !@empty(request.header.contentType)) {
      headers.content-type = request.header.contentType;
    } else {
      headers.content-type = @getContentType(request.objectName);
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, InitiateMultipartUploadResponse);
    return {
      InitiateMultipartUploadResult = respMap.InitiateMultipartUploadResult,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model OptionObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    header: {
      origin: string(description='Origin', name='Origin'),
      accessControlRequestMethod: string(description='Access-Control-Request-Method', name='Access-Control-Request-Method'),
      accessControlRequestHeaders: string(description='Access-Control-Request-Headers', name='Access-Control-Request-Headers'),
    }(description='Header', name='Header'),
  }

  model OptionObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    accessControlAllowOrigin: string(description='Access-Control-Allow-Origin', name='access-control-allow-origin'),
    accessControlAllowMethods: string(description='Access-Control-Allow-Methods', name='access-control-allow-methods'),
    accessControlAllowHeaders: string(description='Access-Control-Allow-Headers', name='access-control-allow-headers'),
    accessControlExposeHeaders: string(description='Access-Control-Expose-Headers', name='access-control-expose-headers'),
    accessControlMaxAge: string(description='Access-Control-Max-Age', name='access-control-max-age'),
  }

  api optionObject(request: OptionObjectRequest, runtime: RuntimeObject): OptionObjectResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'OPTIONS';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PostVodPlaylistRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    channelName: string(description='ChannelName', name='ChannelName'),
    playlistName: string(description='PlaylistName', name='PlaylistName'),
    filter: {
      endTime: string(description='endTime', name='endTime', signed='true'),
      startTime: string(description='startTime', name='startTime', signed='true'),
    }(description='Filter', name='Filter'),
  }

  model PostVodPlaylistResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api postVodPlaylist(request: PostVodPlaylistRequest, runtime: RuntimeObject): PostVodPlaylistResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'POST';
    pathname = `/${request.channelName}/${request.playlistName}?vod`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    query = @toQuery(request.filter);
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PostObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model PostObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    serverSideEncryption: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
  }

  api postObject(request: PostObjectRequest, runtime: RuntimeObject): PostObjectResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'POST';
    pathname = `/`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model HeadObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    header?: {
      ifModifiedSince?: string(description='If-Modified-Since', name='If-Modified-Since'),
      ifUnmodifiedSince?: string(description='If-Unmodified-Since', name='If-Unmodified-Since'),
      ifMatch?: string(description='If-Match', name='If-Match'),
      ifNoneMatch?: string(description='If-None-Match', name='If-None-Match'),
    }(description='Header', name='Header'),
  }

  model HeadObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    userMeta: map[string]string(description='usermeta', name='usermeta'),
    serverSideEncryption: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
    serverSideEncryptionKeyId: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
    storageClass: string(description='x-oss-storage-class', name='x-oss-storage-class'),
    objectType: string(description='x-oss-object-type', name='x-oss-object-type'),
    nextAppendPosition: string(description='x-oss-next-append-position', name='x-oss-next-append-position'),
    hashCrc64ecma: string(description='x-oss-hash-crc64ecma', name='x-oss-hash-crc64ecma'),
    expiration: string(description='x-oss-expiration', name='x-oss-expiration'),
    restore: string(description='x-oss-restore', name='x-oss-restore'),
    processStatus: string(description='x-oss-process-status', name='x-oss-process-status'),
    requestCharged: string(description='x-oss-request-charged', name='x-oss-request-charged'),
    contentMd5: string(description='Content-Md5', name='content-md5'),
    lastModified: string(description='Last-Modified', name='last-modified'),
    accessControlAllowOrigin: string(description='Access-Control-Allow-Origin', name='access-control-allow-origin'),
    accessControlAllowMethods: string(description='Access-Control-Allow-Methods', name='access-control-allow-methods'),
    accessControlMaxAge: string(description='Access-Control-Max-Age', name='access-control-max-age'),
    accessControlAllowHeaders: string(description='Access-Control-Allow-Headers', name='access-control-allow-headers'),
    accessControlExposeHeaders: string(description='Access-Control-Expose-Headers', name='access-control-expose-headers'),
    taggingCount: string(description='x-oss-tagging-count', name='x-oss-tagging-count'),
  }

  api headObject(request: HeadObjectRequest, runtime: RuntimeObject): HeadObjectResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'HEAD';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      usermeta = @toMeta(__response.headers, 'x-oss-meta-'),
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteObjectTaggingRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
  }

  model DeleteObjectTaggingResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteObjectTagging(request: DeleteObjectTaggingRequest, runtime: RuntimeObject): DeleteObjectTaggingResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/${request.objectName}?tagging`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model RestoreObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
  }

  model RestoreObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api restoreObject(request: RestoreObjectRequest, runtime: RuntimeObject): RestoreObjectResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'POST';
    pathname = `/${request.objectName}?restore`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model GetObjectAclRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
  }

  model GetObjectAclResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    accessControlPolicy: {
      owner: {
        iD: string(description='ID', name='ID'),
        displayName: string(description='DisplayName', name='DisplayName'),
      }(description='Owner', name='Owner'),
      accessControlList: {
        grant: string(description='Grant', name='Grant'),
      }(description='AccessControlList', name='AccessControlList'),
    }(description='AccessControlPolicy', name='AccessControlPolicy'),
  }

  api getObjectAcl(request: GetObjectAclRequest, runtime: RuntimeObject): GetObjectAclResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'GET';
    pathname = `/${request.objectName}?acl`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    bodyStr = @readAsString(__response);
    respMap = @parseXml(bodyStr, GetObjectAclResponse);
    return {
      AccessControlPolicy = respMap.AccessControlPolicy,
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutBucketAclRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    header: {
      acl: string(description='x-oss-acl', name='x-oss-acl'),
    }(description='Header', name='Header'),
  }

  model PutBucketAclResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api putBucketAcl(request: PutBucketAclRequest, runtime: RuntimeObject): PutBucketAclResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/?acl`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model DeleteBucketRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
  }

  model DeleteBucketResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
  }

  api deleteBucket(request: DeleteBucketRequest, runtime: RuntimeObject): DeleteBucketResponse {
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'DELETE';
    pathname = `/`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
  model PutObjectRequest = {
    bucketName: string(description='BucketName', name='BucketName'),
    objectName: string(description='ObjectName', name='ObjectName'),
    userMeta?: map[string]string(description='UserMeta', name='UserMeta'),
    body?: readable(description='body', name='body'),
    header?: {
      authorization?: string(description='Authorization', name='Authorization'),
      cacheControl?: string(description='Cache-Control', name='Cache-Control'),
      contentDisposition?: string(description='Content-Disposition', name='Content-Disposition'),
      contentEncoding?: string(description='Content-Encoding', name='Content-Encoding'),
      contentMD5?: string(description='Content-MD5', name='Content-MD5'),
      contentLength?: string(description='Content-Length', name='Content-Length'),
      eTag?: string(description='CETag', name='CETag'),
      expires?: string(description='Expires', name='Expires'),
      serverSideEncryption?: string(description='x-oss-server-side-encryption', name='x-oss-server-side-encryption'),
      serverSideEncryptionKeyId?: string(description='x-oss-server-side-encryption-key-id', name='x-oss-server-side-encryption-key-id'),
      objectAcl?: string(description='x-oss-object-acl', name='x-oss-object-acl'),
      storageClass?: string(description='x-oss-storage-class', name='x-oss-storage-class'),
      tagging?: string(description='x-oss-tagging', name='x-oss-tagging'),
      contentType?: string(description='content-type', name='content-type'),
    }(description='Header', name='Header'),
  }

  model PutObjectResponse = {
    requestId: string(description='x-oss-request-id', name='x-oss-request-id'),
    hashCrc64ecma: string(description='x-oss-hash-crc64ecma', name='x-oss-hash-crc64ecma'),
    serverTime: string(description='x-oss-server-time', name='x-oss-server-time'),
    bucketVersion: string(description='x-oss-bucket-version', name='x-oss-bucket-version'),
  }

  api putObject(request: PutObjectRequest, runtime: RuntimeObject): PutObjectResponse {
    var ref : map[string]string = null;
    var token = @getSecurityToken();
    protocol = @protocol;
    method = 'PUT';
    pathname = `/${request.objectName}`;
    headers = {
      host = getHost(request.bucketName),
      date = @getDate(),
      user-agent = @getUserAgent(),
      ...@toHeader(request.header),
      ...@parseMeta(request.userMeta, 'x-oss-meta-'),
    };
    if (!@empty(token)) {
      headers.x-oss-security-token = token;
    }
    body = @inject(request.body, ref);
    if (@notNull(request.header) && !@empty(request.header.contentType)) {
      headers.content-type = request.header.contentType;
    } else {
      headers.content-type = @getContentType(request.objectName);
    }
    headers.authorization = getSignature(__request, request.bucketName);
  } returns {
    var respMap : object = null;
    var bodyStr : string = null;
    if (@isFail(__response)) {
      bodyStr = @readAsString(__response);
      respMap = @getErrMessage(bodyStr);
      throw {
        code = respMap.Code,
        message = respMap.Message,
        data = {
          httpCode = __response.statusCode,
          requestId = respMap.RequestId,
          hostId = respMap.HostId,
        }
      };
    }
    if (!@equal(ref.crc, __response.headers.x-oss-hash-crc64ecma)) {
      throw {
        code = 'CrcNotMatched',
        data = {
          clientCrc = ref.crc,
          serverCrc = __response.headers.x-oss-hash-crc64ecma,
        },
      };
    }

    if (!@equal(ref.md5, __response.headers.content-md5)) {
      throw {
        code = 'MD5NotMatched',
        data = {
          clientMD5 = ref.md5,
          serverMD5 = __response.headers.content-md5,
        },
      };
    }

    return {
      ...__response.headers,
    };
  } runtime {
    timeouted = 'retry',
    readTimeout = @defaultNumber(runtime.readTimeout, @readTimeout),
    connectTimeout = @defaultNumber(runtime.connectTimeout, @connectTimeout),
    localAddr = @default(runtime.localAddr, @localAddr),
    httpProxy = @default(runtime.httpProxy, @httpProxy),
    httpsProxy = @default(runtime.httpsProxy, @httpsProxy),
    noProxy = @default(runtime.noProxy, @noProxy),
    socks5Proxy = @default(runtime.socks5Proxy, @socks5Proxy),
    socks5NetWork = @default(runtime.socks5NetWork, @socks5NetWork),
    maxIdleConns = @defaultNumber(runtime.maxIdleConns, @maxIdleConns),
    retry = {
      retryable = runtime.autoretry,
      maxAttempts = @defaultNumber(runtime.maxAttempts, 3)
    },
    backoff = {
      policy = @default(runtime.backoffPolicy, 'no'),
      period = @defaultNumber(runtime.backoffPeriod, 1)
    },
    ignoreSSL = runtime.ignoreSSL,
    logger = @logger,
    listener = runtime.listener,
  }
}

